[{"id":"adeogroup","company":{"name":"Adeo Group","description":"Adeo owns different brands in retail industry focused on home improvement and DIY markets, like Leroy Merlin.","customers":"500M","industry":"Retail","revenue":"25.6B EURO turnover, including 768M EURO online.","website":"https://www.adeo.com/","logo":"/img/casestudies/adeo/logo.svg","contact":[{"name":"Ludovic Dussart","link":"https://twitter.com/ldussart"}]},"challenges":"Cost Component Repository product, part of the ADEO tech products, is used to calculate and publish transfer prices between different internal locations on the globe. Different business units use different information systems. It is hard to learn how each business unit share information about their systems, their API and accuracy.\n\nInitial solution was a developer portal with list of all applications and reference to dedicated documentation. Some legacy systems had docs written in MS Excel.\n\nThere was a need for a standart way of describing event-driven architecture.\n","solution":"The API is now described with AsyncAPI. AsyncAPI file, stored together with the source code, is used to generate HTML documentation in the same release pipeline for the product. Documentation is exposed as part of the product internally for other company units depending on the API.\n\nPayloads are described with Avro schema. These schemas are used to generate models and they are also referenced directly in AsyncAPI files thanks to `schemaFormat` feature and `$ref`. This way they make sure code is aligned with docs.\n\nShift to using AsyncAPI also enables the team to implement more use cases using AsyncAPI files.\n","technical":{"languages":["Java"],"frameworks":["Spring"],"protocols":["Kafka"],"brokers":"Kafka with Kafka Connect component. There are 15 production brokers with 47 topics.","testing":"For Kafka e2e tests are done with [Zerocode](https://github.com/authorjapps/zerocode). Load tests are handled with [JMeter](https://jmeter.apache.org/) with [kloadgen](https://github.com/corunet/kloadgen) plugin that supports Kafka and Avro.","architecture":"The following [enterprise integration patterns](https://www.enterpriseintegrationpatterns.com/patterns/messaging) are applied:\n- [Request/Reply](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)\n  Described with `description` field in AsyncAPI. Reply goes to dedicated reply channel.\n  \n  Example description of response channel:\n  ```\n  description: >\n  This topic is used to REPLY Costing Requests and is targeted by the\n  `REPLY_TOPIC` header.\n  ```\n- [Return Address](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ReturnAddress.html)\n  Info that needs to be provided by client, so producer knows where to send a response. Information is sent in message header with `REPLY_TOPIC` property. In the AsyncAPI file, information is documented as part of Message Header object.\n  \n  Example of request message header with `REPLY_TOPIC`:\n  ```\n  headers:\n    type: object\n    required:\n      - REPLY_TOPIC\n    properties:\n      REPLY_TOPIC:\n        $ref: \"#/components/schemas/ReplyTopic\"\n  ```\n- [Correlation Identifier](https://www.enterpriseintegrationpatterns.com/patterns/messaging/CorrelationIdentifier.html)\n  This pattern enables identification of request given response was sent to. \n  \n  `REQUEST_ID` property is in the request message header. `CORRELATION_ID` property is in response message header. Both headers are described in the AsyncAPI Message Header object and referred to in the AsyncAPI `correlationID` property.\n  This means that correlation identifier is represented by different property in the message header, depending if it is a request or reply.\n  \n  Example of request message header with `REQUEST_ID`:\n  ```\n  headers:\n    type: object\n    required:\n      - REQUEST_ID\n    properties:\n      REQUEST_ID:\n        $ref: \"#/components/schemas/RequestId\"\n  ```\n\n  Example of how `correlationId` points to `REQUEST_ID`:\n  ```\n  description: >\n    This correlation ID is used for message tracing and messages\n    correlation.\n    This correlation ID is generated at runtime based on the `REQUEST_ID`\n    and sent to the RESPONSE message.\n  location: $message.header#/REQUEST_ID\n  ````\n- [DeadLetter Channel](https://www.enterpriseintegrationpatterns.com/patterns/messaging/DeadLetterChannel.html)\n  Also known as Dead Letter Queue. In Kafka it is just another channel where undelivered messages are sent. Not part of AsyncAPI file as API consumers will not listen to this channel. Consumers just know what happens with wrong events.\n- [Invalid Message Channel](https://www.enterpriseintegrationpatterns.com/patterns/messaging/InvalidMessageChannel.html)\n  Invalid messages are routed to dedicated channel for rejected requests.  Not part of AsyncAPI file as API consumers will not listen to this channel. Consumers just know what happens with wrong events.\n\n![Architecture Diagram](/img/casestudies/adeo/architecture.webp)\n","codegen":"Java models generation. Avro schemas used as a source.\n"},"schemas":{"description":"Avro 1.9","storage":"Git repository where source code is. During release they are published to Confluent Schema Registry.","registry":"Confluent Schema Registry.","versioning":"Versioning is based on git tags. Schema version pushed to Confluent Schema Registry match the git tag version of the product. Every schema has a `version` information, that match with product tag version.","validation":"Based on validation using Confluent Schema Registry."},"asyncapi":{"usecase":"Document the API of the product so its users know how it works and how to use it. AsyncAPI was selected as the standard that allows you to generate documentation from machine-readable document that describes the API.\nThe goal was to document API in a standardized way, so other internal products could follow to unify the way APIs are documented across the company.\n","versions":["2.4.0"],"storage":"Git repository where source code is.","maintainers":"Developers","editing":"IntelliJ without any special plugins. Sometimes people use AsyncAPI Studio, but not regularly because of lack of support for references to local drive.","audience":{"internal":true,"external":false},"extensions":"Extensions are used to describe details about custom security:\n```yml\n  x-sasl.jaas.config: >-\n    org.apache.kafka.common.security.plain.PlainLoginModule required\n    username=\"<CLUSTER_API_KEY>\" password=\"<CLUSTER_API_SECRET>\";\n  x-security.protocol: SASL_SSL\n  x-ssl.endpoint.identification.algorithm: https\n  x-sasl.mechanism: PLAIN\n````\n","documentation":"Documentation generated from AsyncAPI is hosted as part of the product on dedicated endpoint using Spring controller. \nPublishing is part of CI/CD pipeline for the product using GithubActions.\n\nRelated Maven configuration used to trigger docs generation with AsyncAPI Generator industry:\n\n```\n <profile>\n        <id>generate-asyncapi-doc</id>\n        <build>\n            <plugins>\n                <plugin>\n                    <groupId>com.github.eirslett</groupId>\n                    <artifactId>frontend-maven-plugin</artifactId>\n                    <!-- Use the latest released version:\n                    https://repo1.maven.org/maven2/com/github/eirslett/frontend-maven-plugin/ -->\n                    <version>${frontend-maven-plugin.version}</version>\n                    <configuration>\n                        <nodeVersion>v12.18.4</nodeVersion>\n                        <installDirectory>${node.installation.path}</installDirectory>\n                        <workingDirectory>${node.installation.path}</workingDirectory>\n                    </configuration>\n                    <executions>\n                        <execution>\n                            <id>install node and npm</id>\n                            <goals>\n                                <goal>install-node-and-npm</goal>\n                            </goals>\n                            <phase>generate-resources</phase>\n                        </execution>\n                        <execution>\n                            <id>install @asyncapi/generator globally</id>\n                            <goals>\n                                <goal>npm</goal>\n                            </goals>\n                            <configuration>\n                                <arguments>install @asyncapi/generator@${asyncapi.generator.version}</arguments>\n                            </configuration>\n                        </execution>\n                    </executions>\n                </plugin>\n                <plugin>\n                    <groupId>org.codehaus.mojo</groupId>\n                    <artifactId>exec-maven-plugin</artifactId>\n                    <version>1.6.0</version>\n\n                    <executions>\n                        <execution>\n                            <id>execute-generation</id>\n                            <goals>\n                                <goal>exec</goal>\n                            </goals>\n                            <phase>generate-resources</phase>\n\n                            <configuration>\n                                <!-- Access binary file in node_modules because it doesn't work on windows otherwise. -->\n                                <executable>${node.modules.installation.path}/${ag.binary.name}</executable>\n                                <commandlineArgs>\n                                    ${project.basedir}/src/docs/asyncapi/asyncapi.yaml @asyncapi/html-template@${asyncapi.htmltemplate.version} -p sidebarOrganization=byTags -p\n                                    version=${project.version} -o ${asyncapi.generation.dir}\n                                </commandlineArgs>\n                            </configuration>\n                        </execution>\n                    </executions>\n                </plugin>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-resources-plugin</artifactId>\n                    <executions>\n                        <execution>\n                            <id>copy-resources</id>\n                            <!-- here the phase you need -->\n                            <phase>generate-resources</phase>\n                            <goals>\n                                <goal>copy-resources</goal>\n                            </goals>\n                            <configuration>\n                                <outputDirectory>${asyncapi.generation.dir}/assets</outputDirectory>\n                                <resources>\n                                    <resource>\n                                        <directory>src/docs/asyncapi/assets</directory>\n                                        <filtering>true</filtering>\n                                    </resource>\n                                </resources>\n                            </configuration>\n                        </execution>\n                    </executions>\n                </plugin>\n            </plugins>\n        </build>\n    </profile>\n```\n\nCritical features of AsyncAPI related to documentation:\n- `descriptions` that support `CommonMark` (Markdown) as they allow to put detailed structured descriptions and screenshots inside generated docs\n- examples and validation information. In this case converted from Avro to JSON Schema to show it in documentation and have examples generated\n- `Tags` for tagging operations to categorize them to make it easier to navigate in documentation UI\n","bindings":{"kafka":"All Kafka bindings are used. Server, channel, operation and message bindings.\n\nExample of server bindings:\n```\nbindings:\n  kafka:\n    schema.registry.url: >-\n      https://schema-registry.prod.url/\n```\n\nExample of channel bindings:\n```\nbindings:\n  kafka:\n    replicas: 3\n    partitions: 3\n    cleanup.policy: delete\n    retention.ms: 7 days\n```\n\nExample of operation bindings:\n```\nbindings:\n  kafka:\n    groupId:\n      type: string\n      description: >\n        The groupId must be prefixed by your `svc` account, deliver by the\n        Adeo Kafka team.\n        This `svc` must have the write access to the topic.\n    value.subject.name.strategy:\n      type: string\n      description: >\n        We use the RecordNameStrategy to infer the messages schema.\n        Use\n        `value.subject.name.strategy=io.confluent.kafka.serializers.subject.RecordNameStrategy`\n        in your producer configuration.\n```\n\nExample of message bindings:\n```\nbindings:\n  kafka:\n    key:\n      $ref: \"https://deploy-preview-921--asyncapi-website.netlify.app/resources/casestudies/adeo/CostingResponseKey.avsc\"\n```\n"},"tools":"* [AsyncAPI Generator](https://github.com/asyncapi/generator):\n  * [HTML Template](https://github.com/asyncapi/html-template) with parameters like `sidebarOrganization=byTags` and `version`.\n* [AsyncAPI JavaScript Parser](https://github.com/asyncapi/parser-js) with [Avro Schema Parser](https://github.com/asyncapi/avro-schema-parser).\n","fullExample":"resources/casestudies/adeo/asyncapi.yaml"},"additionalResources":"Watch [this video presentation about AsyncAPI case study](https://www.youtube.com/watch?v=WwhRbvrf6Rs) from Ludovic Dussart, Ineat & Antoine Delequeuche, Adeo."}]