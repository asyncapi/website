id: hdiglobal
company:
  name: HDI Global SE
  description: The HDI brand is used in Germany and abroad by the life and property/casualty insurance companies, which focus on private and corporate customer business, as well as industrial insurance since 2016.
  customers: XXXX
  industry: Insurance
  revenue: XXXX.
  website: https://www.hdi.global/
  logo: /img/casestudies/hdi/hdi_logo.svg
  contact:
    - name: Vladislav Zwenihorodski
      link: https://www.linkedin.com/in/vladislav-zwenihorodski-0b1b3b1b/
challenges: |
  
  The HDI has various platform teams, among them the Integration Platform Team, which offers three products: API Management, Event Hub, and the Azure Service Bus.  
  For synchronous communication, we already use OpenAPI, as such we want to ensure the same level of transparency and discoverability for asynchronous scenarios as well.
  Our central platform team offers the Azure Service Bus with self-service capabilities. 
  Customers are able to manage their own topics and subscribtions by simply modifying the according values in their repositories. 
  This means that most of the data required to document asynchronous communication is already available, although distributed between different repositories.
  This necessitated the creation of a comprehensive catalog of existing topics, allowing potential subscribers easy access to messages from any topics of their choosing.


solution: |
    The solution was to create an AsyncAPI document in which every topic owned by the customer is represented as a channel. 
    The document is automatically generated by a pipeline every time a change in Topic configuartion is applied. The necessary information is read from the customer repositories and then passed to a bash script as input. 
    After the successful creation this file as well as an generated markdown for it are safed within a documentation repository to ensure that the information is accessible for every developer.
technical: #We need some more technical information related to case study.
  languages:
    - bash
  protocols:
    - AMQP
  architecture: |
    The following [enterprise integration patterns](https://www.enterpriseintegrationpatterns.com/patterns/messaging) are applied : 
    - [Message Channel](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageChannel.html)
      Each channel in the AsyncAPI document represents an existing servicebus topic that can be subscribed to.
      ```
      channels:
        helloworld-emea:
          servers: 
            - $ref: '#/servers/box-emea'
          address: https://namespace.namespace/topic/example/helloworld
      ```
    - [Message](https://www.enterpriseintegrationpatterns.com/patterns/messaging/Message.html)
      - The 'messages' section under each channel in the AsyncAPI document represents this pattern. Each message has a name and a payload, which is the data transferred between applications.
      ```
          messages:
            helloworld:
              name: helloworld-Message
              contentType: application/json
              payload:
                $ref: "#/components/schemas/helloworld-topic-v1.json"
      ```
    - [Document Message](https://www.enterpriseintegrationpatterns.com/patterns/messaging/DocumentMessage.html)
      The 'payload' under each message in the AsyncAPI document represents this pattern. The payload is a self-contained document that describes the message and can be understood by the message receiver.
      ```
      payload:
        $ref: "#/components/schemas/helloworld-topic-v1.json"
      ```
      In our repositoriy structure the message-schema file is stored seperatly and just referenced in the Topic configs. 
      To ensure that all information is accesible in one place, the schema is directly copied to the AsyncAPI document.
      ```
      components:
        schemas:
            helloworld-topic-v1.json: {
              "$schema": "http://json-schema.org/draft-06/schema#",
              "type": "object",
              "properties": {
                "eventType": {
                  "type": "object",
                  "enum": [
                    "create",
                    "update",
                    "delete"
                  ]
                },
                "hotel": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string"
                    },
                    "name": {
                      "type": "string"
                    },
                    "slogan": {
                      "type": "string"
                    },
                    "location": {
                      "type": "string"
                    },
                    "total_number_of_rooms": {
                      "type": "integer"
                    },
                    "currently_available_rooms": {
                      "type": "integer"
                    },
                    "currently_occupied_rooms": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "id",
                    "name"
                  ]
                }
              },
              "required": [
                "eventType",
                "hotel"
              ]
            }
      ```
  codegen: |
    #Do you generate code from AsyncAPI? If yes, how do you do it? What tools do you use?
schemas: #It is useful and interesting to learn how teams handle messages schemas.
  description: JSON Schema
  storage: Git repository where customer can store their own config files for the service bus.
  validation: Validated using [Ajv](https://ajv.js.org/)
asyncapi: #More specific details about AsyncAPI itself and how is it used.
  usecase: |
    - used for documentation purposes by the platform team 
    - used to genrate data transfer objects from the AsyncAPI yaml file
  versions:
    - 3.0
  storage: |
    repositoriy for the customer wiki that describes the topics and the messages that can be subscribed to.
  editing: |
    If changes for any topic are applied by a customer the documentation pipline generates the AsyncAPI file using a bash script.
  audience: #Specify if AsyncAPI audience is internal or external or both.
    internal: true
    external: false
  documentation: |
    Documentation is generated via AsyncAPI CLI and published to the wiki right after the AsyncAPI file is generated.
  bindings: |
    #Specify what bindings are used by their name and provide description on what level you use bindings. Provide examples if possible.
  tools: |
    * [AsyncAPI Generator](https://github.com/asyncapi/generator):
      * [markdown-template](https://github.com/asyncapi/markdown-template).
  fullExample: #Should be url to full example of the case study. So later in the UI we can show it as "https://studio.asyncapi.com/?url=https://deploy-preview-921--asyncapi-website.netlify.app/resources/casestudies/adeo/asyncapi.yaml" so the example can be previewed in the AsyncAPI Studio easily.
additionalResources: #Provide some additional resources if there are such. Just block of text with links to articles or videos about the case study.