[{"id":"adeogroup","company":{"name":"Adeo Group","description":"Adeo owns different brands in retail industry focused on home improvement and DIY markets, like Leroy Merlin.","customers":"500M","industry":"Retail","revenue":"25.6B EURO turnover, including 768M EURO online.","website":"https://www.adeo.com/","logo":"/img/casestudies/adeo/logo.svg","contact":[{"name":"Ludovic Dussart","link":"https://twitter.com/ldussart"}]},"challenges":"Cost Component Repository product, part of the ADEO tech products, is used to calculate and publish transfer prices between different internal locations globally. Different business units use different information systems. It is hard to learn how each business unit shares information about its systems, API and accuracy.\n\nThe initial solution was a developer portal with a list of all applications and reference to dedicated documentation. Some legacy systems had docs written in MS Excel.\n\nThere was a need for a standart way of describing event-driven architecture.\n","solution":"The API is now described with AsyncAPI. The AsyncAPI file, stored with the source code, generates HTML documentation in the same release pipeline for the product. Documentation is exposed internally as part of the product for other company units depending on the API.\n\nPayloads are described with Avro schema. These schemas generate models and are referenced directly in AsyncAPI files thanks to the `schemaFormat` feature and `$ref`. This way, they make sure the code is aligned with the docs.\n\nShift to using AsyncAPI also enables the team to implement more use cases using AsyncAPI files.\n","technical":{"languages":["Java"],"frameworks":["Spring"],"protocols":["Kafka"],"brokers":"Kafka with Kafka Connect component. There are 15 production brokers with 47 topics. \n","testing":"For Kafka, e2e tests are done with [Zerocode](https://github.com/authorjapps/zerocode). Load tests are handled with [JMeter](https://jmeter.apache.org/) with the [kloadgen](https://github.com/corunet/kloadgen) plugin that supports Kafka and Avro.\n","architecture":"The following [enterprise integration patterns](https://www.enterpriseintegrationpatterns.com/patterns/messaging) are applied:\n- [Request/Reply](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)\n  Described with `description` field in AsyncAPI. Reply goes to dedicated reply channel. Example description of response channel:\n  ```\n  description: >\n  This topic is used to REPLY Costing Requests and is targeted by the\n  `REPLY_TOPIC` header.\n  ```\n- [Return Address](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ReturnAddress.html)\n  Info that needs to be provided by the client so producer knows where to send a response. Information is sent in the message header with the `REPLY_TOPIC` property. The AsyncAPI file documents information as part of the Message Header object. Example of request message header with `REPLY_TOPIC`:\n  ```\n  headers:\n    type: object\n    required:\n      - REPLY_TOPIC\n    properties:\n      REPLY_TOPIC:\n        $ref: \"#/components/schemas/ReplyTopic\"\n  ```\n- [Correlation Identifier](https://www.enterpriseintegrationpatterns.com/patterns/messaging/CorrelationIdentifier.html)\n  This pattern enables the identification of the request given to the sent response. The `REQUEST_ID` property is in the request message header. The `CORRELATION_ID` property is in the response message header. Both headers are described in the AsyncAPI Message Header object and referred to in the AsyncAPI `correlationID` property.\n  This means that correlation identifier is represented by different property in the message header, depending if it is a request or reply. Example of request message header with `REQUEST_ID`:\n  ```\n  headers:\n    type: object\n    required:\n      - REQUEST_ID\n    properties:\n      REQUEST_ID:\n        $ref: \"#/components/schemas/RequestId\"\n  ```\n  Example of how `correlationId` points to `REQUEST_ID`:\n  ```\n  correlationId:\n    description: >\n      This correlation ID is used for message tracing and messages\n      correlation.\n      This correlation ID is generated at runtime based on the `REQUEST_ID`\n      and sent to the RESPONSE message.\n    location: $message.header#/REQUEST_ID\n  ````\n- [DeadLetter Channel](https://www.enterpriseintegrationpatterns.com/patterns/messaging/DeadLetterChannel.html)\n  Also known as Dead Letter Queue. In Kafka, it is just another channel where undelivered messages are sent. Not part of the AsyncAPI file, as API consumers will not listen to this channel. Consumers know what happens with wrong events.\n- [Invalid Message Channel](https://www.enterpriseintegrationpatterns.com/patterns/messaging/InvalidMessageChannel.html)\n  Invalid messages are routed to the dedicated channel for rejected requests but are not part of the AsyncAPI file, as API consumers will not listen to this channel. Consumers know what happens with wrong events.\n\n![Architecture Diagram](/img/casestudies/adeo/architecture.webp)\n","codegen":"Java models generation. Avro schemas used as a source.\n"},"schemas":{"description":"Avro 1.9","storage":"Git repository where source code is. During release they are published to Confluent Schema Registry.","registry":"Confluent Schema Registry.","validation":"Based on validation using Confluent Schema Registry.","versioning":"Versioning is based on git tags. The schema version pushed to Confluent Schema Registry \nmatches the git tag version of the product. Every schema has a `version` information \nthat matches with product tag version.\n\nExample Avro schema with version information:\n    ```json\n    {\n      \"namespace\": \"com.adeo.casestudy.costingrequest\",\n      \"type\": \"record\",\n      \"name\": \"CostingRequestPayload\",\n      \"version\": \"1.1.0\",\n      \"fields\": [ ... ]\n    }\n    ```\n"},"asyncapi":{"usecase":"Document the API of the product, so its users know how it works and how to use it. AsyncAPI was selected as the standard that allows you to generate documentation from a machine-readable document that describes the API.\nThe goal was to document API in a standardized way, so other internal products could follow to unify how APIs are documented across the company.\n","versions":["2.4.0"],"storage":"Git repository where source code is.","editing":"IntelliJ without any special plugins. Sometimes people use AsyncAPI Studio, but not regularly because of lack of support for references to local drive.","maintainers":"Developers","audience":{"internal":true,"external":false},"extensions":"Extensions are used to describe details about custom security:\n```yml\n  x-sasl.jaas.config: >-\n    org.apache.kafka.common.security.plain.PlainLoginModule required\n    username=\"<CLUSTER_API_KEY>\" password=\"<CLUSTER_API_SECRET>\";\n  x-security.protocol: SASL_SSL\n  x-ssl.endpoint.identification.algorithm: https\n  x-sasl.mechanism: PLAIN\n````\n","documentation":"Documentation generated from AsyncAPI is hosted as part of the product on a dedicated endpoint using Spring controller. \nPublishing is part of the CI/CD pipeline for the product using GithubActions.\n\nRelated Maven configuration used to trigger docs generation with AsyncAPI Generator industry:\n\n```\n <profile>\n        <id>generate-asyncapi-doc</id>\n        <build>\n            <plugins>\n                <plugin>\n                    <groupId>com.github.eirslett</groupId>\n                    <artifactId>frontend-maven-plugin</artifactId>\n                    <!-- Use the latest released version:\n                    https://repo1.maven.org/maven2/com/github/eirslett/frontend-maven-plugin/ -->\n                    <version>${frontend-maven-plugin.version}</version>\n                    <configuration>\n                        <nodeVersion>v12.18.4</nodeVersion>\n                        <installDirectory>${node.installation.path}</installDirectory>\n                        <workingDirectory>${node.installation.path}</workingDirectory>\n                    </configuration>\n                    <executions>\n                        <execution>\n                            <id>install node and npm</id>\n                            <goals>\n                                <goal>install-node-and-npm</goal>\n                            </goals>\n                            <phase>generate-resources</phase>\n                        </execution>\n                        <execution>\n                            <id>install @asyncapi/generator globally</id>\n                            <goals>\n                                <goal>npm</goal>\n                            </goals>\n                            <configuration>\n                                <arguments>install @asyncapi/generator@${asyncapi.generator.version}</arguments>\n                            </configuration>\n                        </execution>\n                    </executions>\n                </plugin>\n                <plugin>\n                    <groupId>org.codehaus.mojo</groupId>\n                    <artifactId>exec-maven-plugin</artifactId>\n                    <version>1.6.0</version>\n\n                    <executions>\n                        <execution>\n                            <id>execute-generation</id>\n                            <goals>\n                                <goal>exec</goal>\n                            </goals>\n                            <phase>generate-resources</phase>\n\n                            <configuration>\n                                <!-- Access binary file in node_modules because it doesn't work on windows otherwise. -->\n                                <executable>${node.modules.installation.path}/${ag.binary.name}</executable>\n                                <commandlineArgs>\n                                    ${project.basedir}/src/docs/asyncapi/asyncapi.yaml @asyncapi/html-template@${asyncapi.htmltemplate.version} -p sidebarOrganization=byTags -p\n                                    version=${project.version} -o ${asyncapi.generation.dir}\n                                </commandlineArgs>\n                            </configuration>\n                        </execution>\n                    </executions>\n                </plugin>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-resources-plugin</artifactId>\n                    <executions>\n                        <execution>\n                            <id>copy-resources</id>\n                            <!-- here the phase you need -->\n                            <phase>generate-resources</phase>\n                            <goals>\n                                <goal>copy-resources</goal>\n                            </goals>\n                            <configuration>\n                                <outputDirectory>${asyncapi.generation.dir}/assets</outputDirectory>\n                                <resources>\n                                    <resource>\n                                        <directory>src/docs/asyncapi/assets</directory>\n                                        <filtering>true</filtering>\n                                    </resource>\n                                </resources>\n                            </configuration>\n                        </execution>\n                    </executions>\n                </plugin>\n            </plugins>\n        </build>\n    </profile>\n```\n\nCritical features of AsyncAPI related to documentation:\n- use of `version` parameter in the generator command to display the release version from the `Maven` pom \n- `descriptions` that support `CommonMark` (Markdown) as they allow to put detailed structured descriptions and screenshots inside generated docs\n- examples and validation information. In this case converted from Avro to JSON Schema to show it in documentation and have examples generated\n- `Tags` for tagging operations to categorize them to make it easier to navigate in documentation UI\n","bindings":"All Kafka bindings are used. Server, channel, operation and message bindings.\n\nExample of server bindings:\n```\nbindings:\n  kafka:\n    schema.registry.url: >-\n      https://schema-registry.prod.url/\n```\n\nExample of channel bindings:\n```\nbindings:\n  kafka:\n    replicas: 3\n    partitions: 3\n    cleanup.policy: delete\n    retention.ms: 7 days\n```\n\nExample of operation bindings:\n```\nbindings:\n  kafka:\n    groupId:\n      type: string\n      description: >\n        The groupId must be prefixed by your `svc` account, deliver by the\n        Adeo Kafka team.\n        This `svc` must have the write access to the topic.\n    value.subject.name.strategy:\n      type: string\n      description: >\n        We use the RecordNameStrategy to infer the messages schema.\n        Use\n        `value.subject.name.strategy=io.confluent.kafka.serializers.subject.RecordNameStrategy`\n        in your producer configuration.\n```\n\nExample of message bindings:\n```\nbindings:\n  kafka:\n    key:\n      $ref: \"https://asyncapi.com/resources/casestudies/adeo/CostingResponseKey.avsc\"\n```\n","tools":"* [AsyncAPI Generator](https://github.com/asyncapi/generator):\n  * [HTML Template](https://github.com/asyncapi/html-template) with parameters like `sidebarOrganization=byTags` and `version`.\n* [AsyncAPI JavaScript Parser](https://github.com/asyncapi/parser-js) with [Avro Schema Parser](https://github.com/asyncapi/avro-schema-parser).\n","fullExample":"resources/casestudies/adeo/asyncapi.yaml"},"additionalResources":"Watch [this video presentation about AsyncAPI case study](https://www.youtube.com/watch?v=WwhRbvrf6Rs) from Ludovic Dussart, Ineat & Antoine Delequeuche, Adeo."},{"id":"hdiglobal","company":{"name":"HDI Global SE","description":"The HDI brand operates in Germany and internationally, offering life and property/casualty insurance services. They cater to both private individuals and corporate clients, and have been providing industrial insurance since 2016.","customers":"5000","industry":"Insurance","revenue":"9.1B EUR","website":"https://www.hdi.global/","logo":"/img/casestudies/hdi/hdi_logo.svg","contact":[{"name":"Vladislav Zwenihorodski","link":"https://www.linkedin.com/in/vladislav-zwenihorodski-9680a1209/"}]},"challenges":"The HDI has various platform teams, among them the Integration Platform team, which offers three products: Azure API Management, Azure Event Hub, and the Azure Service Bus.  \nFor synchronous communication OpenAPI is used as a standard. For asynchronous scenarios we want to use AsyncAPI to achieve the same level of transparency and discoverability.\nWe as platform team offer the Azure Service Bus with self-service capabilities. Our customers are able to manage their own topics and subscriptions by maintaining a custom\nconfiguration model in a GitOps fashion. \nWe want to establish AsyncAPI as documentation standard in HDI's organization. Information about the available message formats and topics is already available in distributed \nsources (e.g. repositories) and needs to be aggregated. \nTo achieve discoverability the creation of a comprehensive catalog of existing topics is necessary, allowing potential subscribers access to information about \nmessages from the available topics, so they can choose which ones to subscribe to.\n","solution":"The solution is to create AsyncAPI documents where each topic owned by the customer is represented as a channel. \nAs we are using the GitOps setup it is straightforward to run pipeline whenever there is a change (commit) in the topic configuration. \nThe necessary information is read from the customer repositories and then passed to a bash script as input. \nAfter successful creation, this file, along with a generated markdown for it, is saved within a documentation repository. \nThis documentation repository serves as the basis for our Azure DevOps wiki, ensuring that all project documentation is centralized and easily accessible.\nAs the documentation wiki is public the information is accessible to every developer, allowing easy access to messages from any topics of their choice.\nThis approach makes our asynchronous communication as transparent and discoverable as our synchronous communication.\n","technical":{"languages":["java, .net, bash"],"frameworks":["Spring Boot"],"protocols":["AMQP"],"brokers":"Azure Service Bus","testing":"n/a","architecture":"The following [enterprise integration patterns](https://www.enterpriseintegrationpatterns.com/patterns/messaging) are applied : \n- [Message Channel](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageChannel.html)\n  Each channel in the AsyncAPI document corresponds to an existing Service Bus topic that can be subscribed to.\n  ```\n  channels:\n    claimStatus-emea:\n      servers:\n        - $ref: '#/servers/box-emea'\n      address: https://namespace.servicebus.windows.net/topic/example/claimStatus\n  ```\n- [Message](https://www.enterpriseintegrationpatterns.com/patterns/messaging/Message.html)\n  The 'messages' section under each channel in the AsyncAPI document adheres to this pattern. \n  Each message is identified by a name and contains a payload, which represents the data transferred between applications.\n  ```\n      messages:\n        claimStatus:\n          name: claimStatus-Message\n          contentType: application/json\n  ```\n- [Document Message](https://www.enterpriseintegrationpatterns.com/patterns/messaging/DocumentMessage.html)\n  The 'payload' under each message in the AsyncAPI document adheres to this pattern. \n  The payload is a self-contained document that describes the message and is comprehensible to the message receiver.\n  ```\n  payload:\n    $ref: '#/components/schemas/claimStatus-example.json'\n  ```\n  In our repository structure, the message-schema file is stored separately and just referenced in the Topic configs. \n  To make sure that all information is accessible in one place, the schema is directly copied to the AsyncAPI document.\n  ```\n  components:\n    schemas:\n        claimStatus-example.json: {\n          \"$schema\": \"http://json-schema.org/draft-06/schema#\",\n          \"type\": \"object\",\n          \"properties\": {\n            \"message\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"version\": {\n                  \"type\": \"string\"\n                },\n                \"header\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"messageId\": {\n                      \"type\": \"string\"\n                    },\n                    \"entityType\": {\n                      \"type\": \"string\"\n                    },\n                    \"eventType\": {\n                      \"type\": \"object\",\n                      \"enum\": [\n                        \"create\",\n                        \"update\"\n                      ]\n                    }\n                  },\n                  \"required\": [\n                    \"messageId\",\n                    \"entityType\",\n                    \"eventType\"\n                  ]\n                },\n                \"data\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"par\": {\n                      \"type\": \"object\",\n                      \"properties\": {\n                        \"tenantNumber\": {\n                          \"type\": \"string\"\n                        },\n                        \"policyNumber\": {\n                          \"type\": \"number\"\n                        },\n                        \"contractNumber\": {\n                          \"type\": \"number\"\n                        },\n                        \"sourceSystem\": {\n                          \"type\": \"string\"\n                        },\n                        \"claimStatus\": {\n                          \"type\": \"string\"\n                        },\n                        \"currencyCode\": {\n                          \"type\": \"string\"\n                        },\n                        \"registrYear\": {\n                          \"type\": \"number\"\n                        },\n                        \"broker\": {\n                          \"type\": \"string\"\n                        },\n                        \"insured\": {\n                          \"type\": \"string\"\n                        },\n                        \"lineOfBusiness\": {\n                          \"type\": \"number\"\n                        },\n                        \"claimCountry\": {\n                          \"type\": \"string\"\n                        },\n                        \"isNewClaim\": {\n                          \"type\": \"boolean\"\n                        },\n                        \"dateOfLoss\": {\n                          \"type\": \"string\",\n                          \"format\": \"date\"\n                        },\n                        \"creationDate\": {\n                          \"type\": \"string\",\n                          \"format\": \"date\"\n                        },\n                        \"notificationDate\": {\n                          \"type\": \"string\",\n                          \"format\": \"date\"\n                        },\n                        \"businessDate\": {\n                          \"type\": \"string\",\n                          \"format\": \"date\"\n                        }\n                      },\n                      \"required\": [\n                        \"tenantNumber\"\n                      ]\n                    }\n                  },\n                  \"required\": [\n                    \"par\"\n                  ]\n                }\n              },\n              \"required\": [\n                \"version\",\n                \"header\",\n                \"data\"\n              ]\n            }\n          },\n          \"required\": [\n            \"message\"\n          ]\n        }\n\n  ```\n","codegen":"Our team currently does not use or ofer a code generation tool. \nHowever, our customers are free to use any tool they prefer to generate DTOs from the AsyncAPI document.\n"},"schemas":{"description":"JSON Schema","storage":"A Git repository functions as a self-service portal where customers can manage their own configurations for the Azure Service Bus. This includes defining their own message schemas for any topics they own.","registry":"none","versioning":"The customer has the freedom to choose the versioning for their own message-schema files.","validation":"Validation using [Ajv](https://ajv.js.org/) is used solely for the purpose of ensuring that the JSON data adheres to the expected schema. This validation is performed for each customer by the Pull Request pipeline we provide. It does not perform any other form of validation or processing on the data."},"asyncapi":{"usecase":"- The AsyncAPI documents are used for documentation purposes by the platform team. \n  It provides a comprehensive overview of the asynchronous communication in our system, including the available topics and the structure of the messages.\n- (Outlook) The AsyncAPI document will be used to generate Java DTOs, ensuring type safety and clear data structure understanding.\n- (Outlook) Having the AsyncAPI documents at hand we are currently planning to use them to configure an internal developer portal (IDP) that will aggregate async and sync APIs among other things.\n- (Outlook) Evaluate if replacing the custom configuration model and use AsyncAPI documents in the center to configure asynchronous communication instead.\n","versions":["3.0.0"],"storage":"A seperate Git repository functions as a \"customer Wiki\", serving as a central location for all relevant documents about the existing infrastructure. \nThis includes the AsyncAPI document, which provides a comprehensive overview of the asynchronous communication in our system.\n","editing":"If changes for any topic are applied by a customer, the documentation pipeline is triggered. \nThis pipeline uses a bash script to read the updated configuration from the customer's repository. \nIt then generates a new AsyncAPI document reflecting these changes.\n\nThe AsyncAPI document is validated using the AsyncAPI CLI to confirm that the document is correctly formatted and adheres to the AsyncAPI specification right after creation and before being commited to the documentation repository.\n","maintainers":"Customers maintain this document automatically by maintaining their own topic configurations.\n","audience":{"internal":true,"external":false},"extensions":"none\n","documentation":"Documentation is generated via AsyncAPI CLI and published to the Azure DevOps wiki right after the AsyncAPI file is generated.\n","bindings":"none\n","tools":"* [AsyncAPI CLI](https://github.com/asyncapi/cli)\n* [AsyncAPI Generator](https://github.com/asyncapi/generator):\n  * [markdown-template](https://github.com/asyncapi/markdown-template).\n","fullExample":"resources/casestudies/hdi/asyncapi.yaml"},"additionalResources":" "}]