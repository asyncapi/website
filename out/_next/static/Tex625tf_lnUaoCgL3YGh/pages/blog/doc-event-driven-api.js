(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{"7ljp":function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return m}));var o=n("q1tI"),r=n.n(o);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=r.a.createContext({}),l=function(e){var t=r.a.useContext(p),n=t;return e&&(n="function"===typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return(r.a.createElement(p.Provider,{value:t},e.children))},b="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return(r.a.createElement(r.a.Fragment,{},t))}},h=r.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(n),b=o,h=u["".concat(i,".").concat(b)]||u[b]||d[b]||a;return n?r.a.createElement(h,s(s({ref:t},p),{},{components:n})):r.a.createElement(h,s({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"===typeof e||o){var a=n.length,i=new Array(a);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[b]="string"===typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=n[p];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},Ff2n:function(e,t,n){"use strict";function o(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,"a",(function(){return o}))},GxjD:function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return l}));var o=n("wx14"),r=n("Ff2n"),a=n("q1tI"),i=n.n(a),s=n("7ljp"),c=(i.a.createElement,{}),p="wrapper";function l(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(s.b)(p,Object(o.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("p",null,"We live in an era of distributed systems. Airlines and hotels communicate with each other to offer us a better experience in our travels; shops work with shipping companies, so we have our new products in our homes in a matter of hours. All of these integrations across services are done using APIs. Those APIs must be well documented so the consumers can integrate with them easily. This is not only a technical matter but also a business-related one."),Object(s.b)("p",null,"Currently, the most used API protocols are ",Object(s.b)("a",{href:"https://en.wikipedia.org/wiki/Representational_state_transfer"},"REST")," and ",Object(s.b)("a",{href:"https://graphql.org/"},"GraphQL"),". You can document your REST API using the ",Object(s.b)("a",{href:"https://swagger.io/specification/"},"OpenAPI")," initiative. In the case of GraphQL, you can use tools like GraphiQL, which makes supported operations visible through ",Object(s.b)("a",{href:"https://graphql.org/learn/introspection/"},"introspection query"),"."),Object(s.b)("p",null,"Both protocols are essentially synchronous: you make a request against the API and wait for a response. But what happens when you are to design an asynchronous event-oriented API? OpenAPI has been designed to document request/response APIs, and GraphQL has its own specific mechanism, so they are not applicable in this case. ",Object(s.b)("a",{href:"https://www.asyncapi.com/"},"AsyncAPI")," to the rescue."),Object(s.b)("hr",null),Object(s.b)("p",null,"Let's imagine you work on a book shopping website called ",Object(s.b)("em",{parentName:"p"},"SuperFunnyBooks"),". Your team is responsible for the ",Object(s.b)("inlineCode",{parentName:"p"},"Catalog Service"),". Book publishers can register new books to the platform through your service. "),Object(s.b)("p",null,Object(s.b)("em",{parentName:"p"},"SuperFunnyBooks")," product team needs a new feature to be added: when a new book is registered on the platform, it has to be recommended to users interested in that genre. To do this, a brand new service, ",Object(s.b)("inlineCode",{parentName:"p"},"Recommendation Service"),", is created and a new team is assigned to. "),Object(s.b)("p",null,"The new service needs to know when a new book is registered in the platform, so ",Object(s.b)("inlineCode",{parentName:"p"},"Catalog Service")," will publish a ",Object(s.b)("inlineCode",{parentName:"p"},"BookRegistered"),' event to a message queue every time this happens. This event will contain information about the new book. But, where is the message queue located? and what does exactly "information about the new book" mean? It sounds a little bit abstract and vague. ',Object(s.b)("inlineCode",{parentName:"p"},"Recommendation Service")," team needs to know every single field that will be included in the event's payload, as well as how to connect to the message queue to start listening for new events. In other words, they need the API documentation. "),Object(s.b)("p",null,"This is how this event-oriented API would look like with AsyncAPI:"),Object(s.b)("pre",null,Object(s.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yaml"}),"asyncapi: 2.0.0\ninfo:\n  title: Catalog Service\n  version: '1.0.0'\n\nservers:\n  production:\n    url: catalog.superfunnybooks.com:9092\n    protocol: kafka\n    description: Production Kafka \n\nchannels:\n  book/registered:\n    description: Book Registered Topic\n    subscribe:\n      summary: Receive information about new book registered in catalog\n      message:\n        name: BookRegistered\n        contentType: application/json\n        payload:\n          type: object\n          properties:\n            bookId:\n              type: string\n            title:\n              type: string\n            author:\n              type: string\n            genre:\n              type: string\n            publisherId:\n              type: string\n            registeredAt:\n              type: string\n              format: datetime\n")),Object(s.b)("p",null,"The first part contains API metadata information. Then, ",Object(s.b)("inlineCode",{parentName:"p"},"servers")," information is declared; in this case, there is a Kafka server running on ",Object(s.b)("inlineCode",{parentName:"p"},"catalog.superfunnybooks.com")," at port ",Object(s.b)("inlineCode",{parentName:"p"},"9092"),". ",Object(s.b)("inlineCode",{parentName:"p"},"channels")," object groups all the operations that the API supports. This one allows consumers to subscribe to ",Object(s.b)("inlineCode",{parentName:"p"},"book/registered")," channel to be notified when a new book is registered. Also, the concrete event's payload schema is defined. "),Object(s.b)("p",null,"With this document, API is properly defined and it provides a contract between ",Object(s.b)("inlineCode",{parentName:"p"},"Catalog Service")," and its consumers. Now, ",Object(s.b)("inlineCode",{parentName:"p"},"Recommendation Service")," knows where the message queue is located in the network and how exactly an event's payload looks like."),Object(s.b)("hr",null),Object(s.b)("p",null,"To sum up, having nice API documentation improves communication between teams in a company as well as between external stakeholders. Also, using a machine-friendly format (like YAML) in API documentation enables it to be integrated into the development lifecycle and the possibility of taking advantage of techniques like server stubbing or automatic testing."),Object(s.b)("p",null,"This has been a simple example of how to use AsyncAPI specifications to document event-oriented APIs. ",Object(s.b)("a",{href:"https://www.asyncapi.com/docs/specifications/2.0.0/#specification"},"AsyncAPI spec")," provides a lot of options that allow to define clearly many aspects of an API. It is worth keeping it in mind."),Object(s.b)("p",null,"I hope you enjoyed this post."),Object(s.b)("p",null,"(Original content from ",Object(s.b)("a",Object(o.a)({parentName:"p"},{href:"https://hvalls.dev/posts/doc-event-driven-api"}),"https://hvalls.dev/posts/doc-event-driven-api"),")"))}l.isMDXComponent=!0},Qetd:function(e,t,n){"use strict";var o=Object.assign.bind(Object);e.exports=o,e.exports.default=e.exports},rFYR:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/doc-event-driven-api",function(){return n("GxjD")}])},wx14:function(e,t,n){"use strict";function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e}).apply(this,arguments)}n.d(t,"a",(function(){return o}))}},[["rFYR",0,1]]]);