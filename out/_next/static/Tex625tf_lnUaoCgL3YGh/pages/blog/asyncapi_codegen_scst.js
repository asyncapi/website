(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{"7ljp":function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return m}));var a=n("q1tI"),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),p=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"===typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return(i.a.createElement(l.Provider,{value:t},e.children))},b="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return(i.a.createElement(i.a.Fragment,{},t))}},h=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=p(n),b=a,h=u["".concat(r,".").concat(b)]||u[b]||d[b]||o;return n?i.a.createElement(h,s(s({ref:t},l),{},{components:n})):i.a.createElement(h,s({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"===typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[b]="string"===typeof e?e:a,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},Ff2n:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}n.d(t,"a",(function(){return a}))},Qetd:function(e,t,n){"use strict";var a=Object.assign.bind(Object);e.exports=a,e.exports.default=e.exports},b1F3:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/asyncapi_codegen_scst",function(){return n("jOGd")}])},jOGd:function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return b}));var a,i=n("wx14"),o=n("Ff2n"),r=n("q1tI"),s=n.n(r),c=n("7ljp"),l=(s.a.createElement,a="YouTube",function(e){return console.warn("Component "+a+" was not imported, exported, or provided by MDXProvider as global scope"),Object(c.b)("div",e)}),p={},u="wrapper";function b(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(c.b)(u,Object(i.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(c.b)("p",null,"Code generation is no simple feat. There are a lot of complexities when it comes to generating useful application code. In this post, I am going to walk you through generating your own microservices using Spring Cloud Stream and the AsyncAPI Code Generator. These tools should help to simplify things when defining and implementing your asynchronous applications. I explained the same idea in a video you can ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://www.youtube.com/watch?v=QEDL6AqsaJc"}),"watch here"),", and all of the artifacts are ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://github.com/Mrc0113/asyncapi-codegen-scst"}),"available in GitHub"),". "),Object(c.b)("blockquote",null,Object(c.b)("p",{parentName:"blockquote"},"This post ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://solace.com/blog/asyncapi-codegen-microservices-using-spring-cloud-stream/"}),"AsyncAPI Code Generation: Microservices Using Spring Cloud Stream")," appeared first on ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://solace.com"}),"Solace"),".")),Object(c.b)("h1",{id:"asyncapi-what-is-it"},"AsyncAPI: What Is It?"),Object(c.b)("p",null,"Before we dive into code generation let\u2019s start with the basics \u2013 what is AsyncAPI? Over the past few years, ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://www.asyncapi.com/"}),"AsyncAPI")," has emerged as the industry standard for defining asynchronous, event-driven APIs; you can think of it as OpenAPI for the asynchronous world. It is an open source initiative that provides ",Object(c.b)("u",null,"both")," a specification to describe and document your asynchronous applications in a machine-readable format, and tooling (such as code generators) to make life easier for developers tasked with implementing them."),Object(c.b)("p",null,"I\u2019m not going to go into great detail about the specification, but for context you should know that it defines metadata about your asynchronous API, the channels available for sending/receiving messages, and components \u2013 such as schemas \u2013 that define the messages that are being exchanged. For more information about the specification you can read about it ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://www.asyncapi.com/docs/specifications/2.0.0/"}),"here"),"."),Object(c.b)("h1",{id:"defining-the-application-that-you-want-to-develop-the--asyncapi-document"},"Defining the Application That You Want to Develop: The  AsyncAPI Document"),Object(c.b)("p",null,"The first step in doing code generation with AsyncAPI is obtaining an AsyncAPI document that defines the application that you want to develop. Per the specification, this document is represented as JSON objects and must conform to the JSON standards. YAML, being a superset of JSON, can also be used. There are two main ways of going about obtaining this document: manually create the document or use an event portal."),Object(c.b)("p",null,"If you decide to manually create the document after familiarizing yourself with the specification, don\u2019t worry \u2013 you won\u2019t be starting with a blank slate. The AsyncAPI initiative has provided a handy, interactive tool called the ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://hub.asyncapi.io/"}),"AsyncAPI Hub")," to make this easier. On the left side of the Hub you can familiarize yourself with the specification and make changes to a real AsyncAPI document, and as you do so the right side of the screen updates to show how the document is parsed into a more human-readable format."),Object(c.b)("p",null,Object(c.b)("img",Object(i.a)({parentName:"p"},{src:"/img/posts/asyncapi-codegen_pic-01.webp",alt:"asyncapi playground for creating microservices using spring cloud stream"}))),Object(c.b)("p",null,"The second way is to use an event portal. Solace PubSub+ Event Portal, for example, allows for architects and developers to collaborate using a GUI to design your event-driven architecture. The team would define the applications that exist in the system, as well as the events that are exchanged and the schemas which define them. Having a catalog of well-organized channels and events for reuse will also save you both time and headaches while collaborating, instead of having to comb through a bunch of files in various locations."),Object(c.b)("p",null,"Once the design is in place, PubSub+ Event Portal allows the developer to choose the application they are responsible for developing and download the AsyncAPI document in JSON or YAML."),Object(c.b)("p",null,Object(c.b)("img",Object(i.a)({parentName:"p"},{src:"/img/posts/asyncapi-codegen_pic-02.webp",alt:"pic2"}))),Object(c.b)("h1",{id:"create-event-driven-microservices-using-spring-cloud-stream-without-learning-messaging-apis"},"Create Event-Driven Microservices Using Spring Cloud Stream Without Learning Messaging APIs"),Object(c.b)("p",null,"Now that we have our AsyncAPI document that describes our application it\u2019s time to develop the application. The AsyncAPI ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://github.com/asyncapi/generator"}),"Code Generator")," supports templates to generate code for a variety of different languages and protocols, but for this example we\u2019re going to use the ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://github.com/asyncapi/java-spring-cloud-stream-template"}),"Spring Cloud Stream template"),". One should note that the template generates a Maven project."),Object(c.b)("p",null,"The Spring Cloud Stream framework provides an easy way to get started with event-driven microservices by providing binders that allow the developer to create their microservices without having to learn messaging APIs."),Object(c.b)("h3",{id:"download-and-run-the-asyncapi-generator"},"Download and Run the AsyncAPI Generator"),Object(c.b)("p",null,"The first step is of course to install the AsyncAPI generator itself. If you have NodeJS installed this takes just one easy ",Object(c.b)("inlineCode",{parentName:"p"},"npm")," command as seen below. You can find the required versions in the ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://github.com/asyncapi/generator"}),"Code Generator")," on github."),Object(c.b)("pre",null,Object(c.b)("code",Object(i.a)({parentName:"pre"},{className:"language-bash"}),"npm install -g @asyncapi/generator\n")),Object(c.b)("p",null,"Once you have the generator installed you can run it using the ",Object(c.b)("inlineCode",{parentName:"p"},"ag")," command. At a minimum you must specify the AsyncAPI document to run it against and the template to use as shown below."),Object(c.b)("pre",null,Object(c.b)("code",Object(i.a)({parentName:"pre"},{className:"language-generator-cli"}),"ag https://raw.githubusercontent.com/asyncapi/asyncapi/2.0.0/examples/2.0.0/streetlights.yml @asyncapi/java-spring-cloud-stream-template\n")),Object(c.b)("p",null,"In most cases you\u2019ll want to take advantage of the parameters and specification extensions that are specified by the template being used. For example, the Spring Cloud Stream template that I\u2019m using in this example allows me to ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://github.com/asyncapi/java-spring-cloud-stream-template#configuration-options"}),"configure many options"),", including the Spring Cloud Stream binder I want to use \u2013 for example, the Solace binder."),Object(c.b)("p",null,"Other parameters include:"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},"Maven information: ",Object(c.b)("inlineCode",{parentName:"li"},"artifactId")," and ",Object(c.b)("inlineCode",{parentName:"li"},"groupId")),Object(c.b)("li",{parentName:"ul"},"Java package: ",Object(c.b)("inlineCode",{parentName:"li"},"javaPackage")),Object(c.b)("li",{parentName:"ul"},"Broker connection Info: ",Object(c.b)("inlineCode",{parentName:"li"},"host"),", ",Object(c.b)("inlineCode",{parentName:"li"},"username"),", ",Object(c.b)("inlineCode",{parentName:"li"},"password")," and ",Object(c.b)("inlineCode",{parentName:"li"},"msgVpn"))),Object(c.b)("p",null,"Using these options, my ",Object(c.b)("inlineCode",{parentName:"p"},"ag")," command might look something like this, where ",Object(c.b)("inlineCode",{parentName:"p"},"-o")," specifies the output directory:"),Object(c.b)("pre",null,Object(c.b)("code",Object(i.a)({parentName:"pre"},{className:"language-generator-cli"}),"ag -o ExpenseIntegration -p binder=solace -p view=provider -p actuator=true -p artifactId=ExpenseIntegration -p groupId=acme.rideshare -p javaPackage=acme.rideshare.expense -p host=localhost:55555 -p username=default -p password=default -p msgVpn=default ~/Downloads/ExpenseIntegration.yaml @asyncapi/java-spring-cloud-stream-template\n")),Object(c.b)("p",null,"After running, the output will look something like this:",Object(c.b)("br",{parentName:"p"}),"\n",Object(c.b)("img",Object(i.a)({parentName:"p"},{src:"/img/posts/asyncapi-codegen_pic-03.webp",alt:"pic3"}))),Object(c.b)("h1",{id:"add-your-business-logic"},"Add Your Business Logic"),Object(c.b)("p",null,"At this point the generator has created an ",Object(c.b)("inlineCode",{parentName:"p"},"ExpenseIntegration")," directory that contains the Maven project. We can use the IDE of choice and import the Maven project to add business logic."),Object(c.b)("p",null,"As seen in the image below, once imported, the project looks like a regular Spring Boot Java project with generated classes under the ",Object(c.b)("inlineCode",{parentName:"p"},"javaPackage")," that was defined earlier and an ",Object(c.b)("inlineCode",{parentName:"p"},"application.yml")," file for configuration. Generated classes under ",Object(c.b)("inlineCode",{parentName:"p"},"javaPackage")," include Plain Old Java Objects (POJOs) defined from the schemas in the AsyncAPI document and ",Object(c.b)("inlineCode",{parentName:"p"},"Application.java")," which contains the actual Spring Cloud Functions where we\u2019ll add our business logic.",Object(c.b)("br",{parentName:"p"}),"\n",Object(c.b)("img",Object(i.a)({parentName:"p"},{src:"/img/posts/asyncapi-codegen_pic-04.webp",alt:"pic4"}))),Object(c.b)("p",null,"The generated POJOs, like ",Object(c.b)("inlineCode",{parentName:"p"},"RideReceipt")," in the image above, define your data model per the schemas included in the AsyncAPI document. These POJOs contains variables with getters and setters for each attribute defined to allow both for developers to get coding quickly without having to manually create the objects themselves, but also for Spring Cloud Stream to automatically convert messages directly to POJOs."),Object(c.b)("p",null,"Then we have the ",Object(c.b)("inlineCode",{parentName:"p"},"Application.java")," class, which can be renamed using the ",Object(c.b)("inlineCode",{parentName:"p"},"javaClass")," parameter. The generator will add functions to handle messages delivered on the channels defined in the AsyncAPI document ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://github.com/asyncapi/java-spring-cloud-stream-template#how-it-works"}),"as described in the template"),"."),Object(c.b)("p",null,"In the example below we can see a single ",Object(c.b)("inlineCode",{parentName:"p"},"java.util.function.Consumer")," bean since our AsyncAPI document describes our application as a subscriber to messages whose payload is defined by the ",Object(c.b)("inlineCode",{parentName:"p"},"RideReceipt")," schema. Note the comment that states // Add business logic here; this is where the developer can add their business logic."),Object(c.b)("pre",null,Object(c.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"@SpringBootApplication\npublic class Application {\n   private static final Logger logger = LoggerFactory.getLogger(Application.class);\n   public static void main(String[] args) {\n      SpringApplication.run(Application.class);\n   }\n\n   @Bean\n   public Consumer<RideReceipt> acmeRideshareBillingReceiptCreated001Consumer() {\n      // Add business logic here.\n      return null;\n   }\n}\n")),Object(c.b)("p",null,"You might say: \u201cMarc, that\u2019s great, but how the heck is that function actually binding to the messaging channels!?\u201d This is where the ",Object(c.b)("inlineCode",{parentName:"p"},"application.yml")," file comes into play."),Object(c.b)("p",null,"The generated ",Object(c.b)("inlineCode",{parentName:"p"},"application.yml")," file defines several things as specified in the AsyncAPI document or from the parameters passed into the generator. First, it defines the list of functions it wants Spring Cloud Stream aware of under ",Object(c.b)("inlineCode",{parentName:"p"},"spring.cloud.stream.function.definition"),". Second, it tells Spring Cloud Stream which channels to bind those functions to under ",Object(c.b)("inlineCode",{parentName:"p"},"spring.cloud.streams.bindings"),". Lastly, it contains connection information to the messaging system. The connection info is specified by different parameters depending on the binder you choose but, in this case, it\u2019s defined under ",Object(c.b)("inlineCode",{parentName:"p"},"solace.java"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(i.a)({parentName:"pre"},{className:"language-yaml"}),"spring: \n  cloud: \n    stream: \n      function: \n        definition: acmeRideshareBillingReceiptCreated001Consumer \n    bindings: \n      acmeRideshareBillingReceiptCreated001Consumer-in-0:\n        destination: acme/rideshare/billing/receipt/created/0.0.1\n\nsolace: \n  java: \n    host: 'localhost:55555' \n    msgVpn: default \n    clientUsername: default \n    clientPassword: default\n\nlogging: \n  level: \n    root: info \n    org: \n      springframework: info\n")),Object(c.b)("p",null,"Note that all of this was done for the developer so they didn\u2019t have to track down which SCSt parameters needed to be set, map the functions to the bindings, etc. They just have to add their business logic in place of the project and hit run! In this case since it\u2019s a Spring Boot project you can \u201crun as a Spring Boot app\u201d in your IDE or even run from the command line using ",Object(c.b)("inlineCode",{parentName:"p"},"mvn spring-boot:run"),"."),Object(c.b)("h1",{id:"helpful-parameters-and-specification-extensions-for-creating-microservices-using-the-asyncapi-spring-cloud-stream-template"},"Helpful Parameters and Specification Extensions for Creating Microservices Using the AsyncAPI Spring Cloud Stream Template"),Object(c.b)("p",null,"As I mentioned, there are a lot of complexities when it comes to generating useful application code from a microservice. Because of these complexities, I thought I\u2019d call out some tips, tricks, and painpoints of using the AsyncAPI Spring Cloud Stream template."),Object(c.b)("p",null,"There are a bunch of different parameters and specification extensions that you should consider when generating your code. All of them can be found ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://github.com/asyncapi/java-spring-cloud-stream-template#configuration-options"}),"here"),", but I\u2019ll go over a few of the parameters that I use quite often:"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},"The ",Object(c.b)("inlineCode",{parentName:"li"},"binder")," parameter allows you to specify the Spring Cloud Stream binder that you\u2019d like to use. Currently the generator supports ",Object(c.b)("inlineCode",{parentName:"li"},"kafka"),", ",Object(c.b)("inlineCode",{parentName:"li"},"rabbit")," and ",Object(c.b)("inlineCode",{parentName:"li"},"solace"),"."),Object(c.b)("li",{parentName:"ul"},"The ",Object(c.b)("inlineCode",{parentName:"li"},"info.x-view")," specification extension can be set at the info level in your AsyncAPI document. This extension allows for you to define how the document should be viewed from an application perspective. By default an AsyncAPI specification takes a ",Object(c.b)("inlineCode",{parentName:"li"},"client")," view where operations (publish/subscribe) defined in a document represent what an application accepts (or how you would communicate with that application). However, for code generation you may want to  generate what an application actually does. This is where setting the ",Object(c.b)("inlineCode",{parentName:"li"},"view")," parameter comes in. If you set ",Object(c.b)("inlineCode",{parentName:"li"},"view")," to a value of ",Object(c.b)("inlineCode",{parentName:"li"},"provider"),"  the operations defined in the document will be treated as what an application actually does. Note that this extension can also be set using the ",Object(c.b)("inlineCode",{parentName:"li"},"view")," parameter on some generator templates, such as the Java Spring Cloud Stream one. "),Object(c.b)("li",{parentName:"ul"},"The ",Object(c.b)("inlineCode",{parentName:"li"},"operation.x-scs-function-name")," specification extension can be set on your ",Object(c.b)("inlineCode",{parentName:"li"},"publish")," or ",Object(c.b)("inlineCode",{parentName:"li"},"subscribe")," operations in the AsyncAPI document, allowing you not only to name the generated function, but also tie two operations together to form a function that subscribes to one channel and publishes to another when the same name is used. For example, if your AsyncAPI document looked like the image below a ",Object(c.b)("inlineCode",{parentName:"li"},"java.util.function.Function")," bean called \u201ccalculatePercentage\u201d would be generated which subscribes to the input channel and publishes to the output channel.")),Object(c.b)("pre",null,Object(c.b)("code",Object(i.a)({parentName:"pre"},{className:"language-yaml"}),"channels:\n  'input':\n    subscribe:\n      x-scs-function-name: calculatePercentage\n      message:\n        $ref: '#/components/messages/CovidTracking_SingleStateCurrentDataUpdate'\n  'output':\n    publish:\n      x-scs-function-name: calculatePercentage\n      message:\n        $ref: '#/components/messages/CovidTracking_SingleStateTestPercentagesUpdate'\n")),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},"The ",Object(c.b)("inlineCode",{parentName:"li"},"x-scs-destination")," specification extension can be specified on a ",Object(c.b)("inlineCode",{parentName:"li"},"subscribe")," operation, allowing you to override the default destination value which usually matches the channel. This is useful when you are using the Solace binder and you are following the Solace pattern of publishing to topics and consuming from queues. In this case the ",Object(c.b)("inlineCode",{parentName:"li"},"x-scs-destination")," value would be treated as the name of the queue which your microservice will consume from and the channel name in the AsyncAPI document will be added as a topic subscription to that queue."),Object(c.b)("li",{parentName:"ul"},"The ",Object(c.b)("inlineCode",{parentName:"li"},"x-scs-group")," specification extension can also be specified on a ",Object(c.b)("inlineCode",{parentName:"li"},"subscribe")," operation, allowing for the addition of a ",Object(c.b)("inlineCode",{parentName:"li"},"group")," to the generated Spring Cloud Stream ",Object(c.b)("inlineCode",{parentName:"li"},"binding"),". This allows for the use of consumer groups and will end up in a ",Object(c.b)("a",Object(i.a)({parentName:"li"},{href:"https://dev.to/solacedevs/understanding-solace-endpoints-durable-vs-non-durable-53gd"}),"durable queue")," being created when using the Solace binder.")),Object(c.b)("h1",{id:"tips-for-using-the-code-generator-to-create-event-driven-microservices-using-spring-cloud-stream"},"Tips For Using The Code Generator To Create Event-Driven Microservices Using Spring Cloud Stream"),Object(c.b)("p",null,"Besides configuration options there are a few more things to keep in mind when using the generator to create event-driven microservices using Spring Cloud Stream."),Object(c.b)("ol",null,Object(c.b)("li",{parentName:"ol"},"Make sure generated POJOs have the Java types you would expect for generated variables! For example, if your JSON schema defines an attribute type as a ",Object(c.b)("inlineCode",{parentName:"li"},"number")," or ",Object(c.b)("inlineCode",{parentName:"li"},"integer")," those are being mapped to a ",Object(c.b)("inlineCode",{parentName:"li"},"Double")," or ",Object(c.b)("inlineCode",{parentName:"li"},"Integer")," in Java respectively. If you would like another type, such as a float or long, you\u2019ll want to make that change. It is also important to make sure you pay close attention to data that represents dates and/or times as those will likely end up just being represented by a ",Object(c.b)("inlineCode",{parentName:"li"},"String")," by default."),Object(c.b)("li",{parentName:"ol"},"Dynamic topics are not yet supported by the AsyncAPI SCSt Code Generator. We\u2019ll be looking to enhance them both to support dynamic topics in the future but for now you\u2019ll want to remove dynamic pieces of the topic from your channels in the AsyncAPI document and add them into the code afterwards."),Object(c.b)("li",{parentName:"ol"},"When creating a Spring Cloud Stream microservice that does ",Object(c.b)("em",{parentName:"li"},"not")," contain a ",Object(c.b)("inlineCode",{parentName:"li"},"java.util.function.Supplier")," include a web server so the microservice continues running and listening for messages to process. This can be done by including the ",Object(c.b)("inlineCode",{parentName:"li"},"-p actuator=true")," parameter to include Spring Actuator functionality which itself requires a web server, and also provides some cool management and monitoring capabilities. Alternatively, you can just add the ",Object(c.b)("inlineCode",{parentName:"li"},"spring-boot-starter-web")," starter to your pom after it\u2019s been generated. Note this is not an issue with the AsyncAPI generator template, but just a bug with the Solace Spring Cloud Stream binder which will be relevant to people using the generator.")),Object(c.b)("p",null,"I hope those tips are helpful and save you some troubleshooting time!"),Object(c.b)("h1",{id:"conclusion"},"Conclusion"),Object(c.b)("p",null,"I hope this post was useful and you\u2019re able to quickly dive in to generating your own event-driven microservices using Spring Cloud Stream and the AsyncAPI Code Generator after exploring the example described above."),Object(c.b)("p",null,"You can get started right away and use the Solace PubSub+ Event Portal to generate your AsyncAPI document for FREE by signing up for a ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"https://console.solace.cloud/login/new-account"}),"new cloud account"),"!"),Object(c.b)("p",null,"If you have more questions or want to share your experience with the tools, you can let us know in the ",Object(c.b)("a",Object(i.a)({parentName:"p"},{href:"http://solace.community/"}),"Solace Community Forum")," or consider joining us in contributing directly to the AsyncAPI initiative."),Object(c.b)(l,{id:"https://www.youtube.com/embed/QEDL6AqsaJc",mdxType:"YouTube"}))}b.isMDXComponent=!0},wx14:function(e,t,n){"use strict";function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}n.d(t,"a",(function(){return a}))}},[["b1F3",0,1]]]);