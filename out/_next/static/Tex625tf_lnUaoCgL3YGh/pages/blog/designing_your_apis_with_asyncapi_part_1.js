(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{"7ljp":function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return u}));var a=n("q1tI"),r=n.n(a);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=r.a.createContext({}),l=function(e){var t=r.a.useContext(p),n=t;return e&&(n="function"===typeof e?e(t):o(o({},t),e)),n},b=function(e){var t=l(e.components);return(r.a.createElement(p.Provider,{value:t},e.children))},h="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return(r.a.createElement(r.a.Fragment,{},t))}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),b=l(n),h=a,d=b["".concat(i,".").concat(h)]||b[h]||m[h]||s;return n?r.a.createElement(d,o(o({ref:t},p),{},{components:n})):r.a.createElement(d,o({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"===typeof e||a){var s=n.length,i=new Array(s);i[0]=d;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[h]="string"===typeof e?e:a,i[1]=o;for(var p=2;p<s;p++)i[p]=n[p];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},Ff2n:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,"a",(function(){return a}))},MCFY:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/designing_your_apis_with_asyncapi_part_1",function(){return n("Si2f")}])},Qetd:function(e,t,n){"use strict";var a=Object.assign.bind(Object);e.exports=a,e.exports.default=e.exports},Si2f:function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return l}));var a=n("wx14"),r=n("Ff2n"),s=n("q1tI"),i=n.n(s),o=n("7ljp"),c=(i.a.createElement,{}),p="wrapper";function l(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)(p,Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"How can you utilize code generation to speed up the development process and only focus on what is important - the business logic? In this miniseries, I will explore the ways AsyncAPI and code generation can work hand in hand beyond generating documentation."),Object(o.b)("p",null,"Structure of the miniseries:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Part 1: Designing your APIs with AsyncAPI")),Object(o.b)("li",{parentName:"ul"},"Part 2: Implementing your applications using code generation"),Object(o.b)("li",{parentName:"ul"},"Part 3: Black-box testing the applications using code generation"),Object(o.b)("li",{parentName:"ul"},"Part 4: Introducing new changes when using code generation"),Object(o.b)("li",{parentName:"ul"},"Part 5: The path to 1 billion players - Scaling the applications and finding bottlenecks with tooling")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Don't see this blog post series as anything other than an example workflow. This is purely how I do it with my applications and how I use AsyncAPI and its tooling to my advantage. Use this as an inspiration to finding an approach that works for you.")),Object(o.b)("h1",{id:"backstory"},"Backstory"),Object(o.b)("p",null,"Back in 2019 when I started contributing to the tooling of AsyncAPI, I was still in university studying for a master's in software engineering and had at that point been a student developer at a company called ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://eurisco.dk/"}),"EURISCO"),", for about 3 years. Besides that, I have always had side projects that I worked on in my spare time, and it was one of these side projects that sparked my need for AsyncAPI. "),Object(o.b)("p",null,"My side project at that time was a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://rust.facepunch.com/"}),"Rust")," game server plugin that collected in-game events, such as when a player farms resources, kills another player, loots a container, etc, and send them to a backend. Later these could be extracted by an API to display the player's progression and detailed account of what the player did on the game server. "),Object(o.b)("p",null,"Initially, I used OpenAPI to describe the REST API, and the community tooling allowed me to generate clients and servers in different languages, which accelerated the implementation process."),Object(o.b)("p",null,"I soon encountered a use case that required me to push data to the game server, and solving this with REST was possible but cumbersome. So I started exploring different alternatives in terms of event-driven architecture. However, none could be described using OpenAPI removing tooling, so I had to find alternatives. "),Object(o.b)("p",null,"That was when I vaguely remembered a meeting in the company where AsyncAPI was mentioned. Around that time, we began to switch from a custom socket protocol to ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://nats.io/"}),"NATS")," and spend some time figuring out how to mainstream the process for both documenting and generating code for the APIs. This was where we had found AsyncAPI and started adopting the specification."),Object(o.b)("p",null,"So I started to look into AsyncAPI for my project, which sparked my first ever contribution to an open-source project, but that is a story for another time, maybe."),Object(o.b)("p",null,"So this blog post is a dedication to that experience, showcasing how I use AsyncAPI to document and generate code to speed up the development process and maybe spark your interest in helping us build the best tooling possible."),Object(o.b)("h1",{id:"to-that-end"},"To that end"),Object(o.b)("p",null,"Explaining something is always better with actual examples, therefore I will be creating a little system to show you how code generation can support the development process. "),Object(o.b)("figure",null,Object(o.b)("img",{src:"/img/posts/jonaslagoni-miniseries-part1/blog-miniseries-general-setup.webp",title:"General setup of the project"}),Object(o.b)("figcaption",{className:"text-center text-gray-400 text-sm"},'The general setup of the project, with the two applications game server and processor. The round dot between "some broker" and the applications represent how others may grab/interact with the application, ergo its API.')),Object(o.b)("p",null,"I will be creating a system of two applications, a ",Object(o.b)("strong",{parentName:"p"},"game server")," and a ",Object(o.b)("strong",{parentName:"p"},"processor")," using a micro-service architecture with no public-facing API. How a player interacts with the ",Object(o.b)("strong",{parentName:"p"},"game server")," could be through a phone, a computer, Xbox, or PlayStation. I only care about the interaction between the ",Object(o.b)("strong",{parentName:"p"},"game server")," and the ",Object(o.b)("strong",{parentName:"p"},"processor")," in this blog post. "),Object(o.b)("p",null,"The ",Object(o.b)("strong",{parentName:"p"},"game server")," will produce the following events: when players join the server, pick up items in-game, uses the chat, hit one another, and eventually disconnect. It will be implemented to simulate players at random intervals joins the server, perform the different actions, and eventually disconnect to provide a sense of realism. "),Object(o.b)("p",null,"The backend ",Object(o.b)("strong",{parentName:"p"},"processor")," will be consuming these events to process them. In this series, I will not do anything particular with the data. The ",Object(o.b)("strong",{parentName:"p"},"Processor")," will simply save the received events directly to a database."),Object(o.b)("p",null,"I will not get into the specifics of the stack for this system yet since it does not affect the writing of the API documents for the two applications."),Object(o.b)("h1",{id:"designing-the-apis-with-asyncapi"},"Designing the APIs with AsyncAPI"),Object(o.b)("p",null,"When starting designing the application APIs I always use the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://apisyouwonthate.com/blog/api-design-first-vs-code-first"}),"design first principle"),", even when we are talking about internal systems."),Object(o.b)("h2",{id:"the-game-server"},"The game server"),Object(o.b)("p",null,"I always start with the basics and define all the different channels for which the ",Object(o.b)("strong",{parentName:"p"},"game server")," should produce events over."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'asyncapi: 2.0.0\ninfo: \n  title: "Game server"\n  version: "0.0.1"\nchannels: \n  game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:\n    description: Channel used when a player picks up an item in-game\n  game/server/{serverId}/events/player/{playerId}/connect:\n    description: Channel used when a player joins (connect to) the game server\n  game/server/{serverId}/events/player/{playerId}/disconnect:\n    description: Channel used when a player leaves (disconnects from) the game server\n  game/server/{serverId}/events/player/{playerId}/chat: \n    description: Channel used when a player writes something in chat\n  game/server/{serverId}/events/player/{playerId}/hit: \n    description: Channel used when a player hit another player in-game\n')),Object(o.b)("p",null,"AsyncAPI channels have a different meaning based on the underlying setup. For brokers such as ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://kafka.apache.org/"}),"Apache Kafka"),", this is referred to as ",Object(o.b)("inlineCode",{parentName:"p"},"topics"),". "),Object(o.b)("p",null,"However, regardless of the underlying setup, channels must be defined as a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.asyncapi.com/docs/specifications/2.0.0#channelsObject"}),"RFC 6570 URI template"),". "),Object(o.b)("p",null,"The way I like to structure my channels is to utilize parameters to separate the action from information about the event, so it describes, on what server the event was performed ",Object(o.b)("inlineCode",{parentName:"p"},"{serverId}"),", by what player ",Object(o.b)("inlineCode",{parentName:"p"},"{playerId}")," and in case of ",Object(o.b)("strong",{parentName:"p"},"pickup"),", what item ",Object(o.b)("inlineCode",{parentName:"p"},"{itemId}")," gets picked up. For the last part of the channel, I describe what event it was, ",Object(o.b)("strong",{parentName:"p"},"pickup"),", ",Object(o.b)("strong",{parentName:"p"},"connect"),", ",Object(o.b)("strong",{parentName:"p"},"disconnect"),", etc."),Object(o.b)("p",null,"Next I define the actual definition of the channels, and here I will focus on explaining the channel ",Object(o.b)("inlineCode",{parentName:"p"},"game/server/{server_id}/events/player/{player_id}/item/{item_id}/pickup"),". The full AsyncAPI document can be found ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jonaslagoni/asyncapi-miniseries/blob/master/AsyncAPI/GameServer.yaml"}),"here"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-YAML"}),"...\n  game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:\n    description: Channel used when a player picks up an item in-game\n    parameters:\n      serverId: \n        description: The id of the server the action was performed on\n        schema: \n          type: string\n      playerId: \n        description: The id of the player who performed the action\n        schema: \n          type: string\n      itemId: \n        description: The id of item picked up\n        schema: \n          type: string\n    subscribe: \n      message:\n        payload:\n          type: object\n          properties:\n            pickupTimestamp:\n              type: string\n              format: date-time\n              description: The timestamp the item was picked up\n          $id: PlayerItemPickupPayload\n          additionalProperties: false\n...\n")),Object(o.b)("p",null,"First, I have the definition of ",Object(o.b)("strong",{parentName:"p"},"parameters")," used in the channel. ",Object(o.b)("strong",{parentName:"p"},"serverId")," tells us where the action originates from, the ",Object(o.b)("strong",{parentName:"p"},"playerId")," tells us who performed the action, and the ",Object(o.b)("strong",{parentName:"p"},"itemId")," tells us which item was picked up and should all validate against a value with type ",Object(o.b)("strong",{parentName:"p"},"string"),"."),Object(o.b)("figure",null,Object(o.b)("img",{src:"/img/posts/jonaslagoni-miniseries-part1/blog-miniseries-gameserver-api.webp",title:"Game server setup"}),Object(o.b)("figcaption",{className:"text-center text-gray-400 text-sm"},'Displays the game server API as it is described with AsyncAPI with version 2.0.0. The round dot between "some broker" and the game server represent how others may grab/consume the produced event from the game server.')),Object(o.b)("p",null,"Next, we have the ",Object(o.b)("strong",{parentName:"p"},"subscribe")," operation, which might not make much sense at first glance. I do want the ",Object(o.b)("strong",{parentName:"p"},"game server")," to publish this event, right?"),Object(o.b)("p",null,"And you would be correct, but this is how you currently define operations in AsyncAPI. You define the operation others may interact with. This means that the ",Object(o.b)("strong",{parentName:"p"},"game server")," publishes on this channel and others may ",Object(o.b)("strong",{parentName:"p"},"subscribe")," to it ","[",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#view-property"}),"1"),"]","[",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#clarify-view"}),"3"),"]",". If you want a more detailed explanation, I suggest reading Nic Townsend's post about ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.asyncapi.com/blog/publish-subscribe-semantics"}),"Demystifying the Semantics of Publish and Subscribe"),". "),Object(o.b)("p",null,"The ",Object(o.b)("strong",{parentName:"p"},"payload")," of the channel (is described using a super-set of JSON Schema draft 7) should validate against an ",Object(o.b)("strong",{parentName:"p"},"object")," which contains the property ",Object(o.b)("strong",{parentName:"p"},"pickupTimestamp"),", which should validate against a ",Object(o.b)("strong",{parentName:"p"},"string"),". When ",Object(o.b)("strong",{parentName:"p"},"additionalProperties")," is ",Object(o.b)("strong",{parentName:"p"},"false"),", no extra properties may be added to the object (by default this is ",Object(o.b)("strong",{parentName:"p"},"true")," in JSON Schema draft 7). The ",Object(o.b)("strong",{parentName:"p"},"$id")," keyword is used as an identifier for that specific schema, in this case, I name the object schema ",Object(o.b)("strong",{parentName:"p"},"PlayerItemPickupPayload"),"."),Object(o.b)("h2",{id:"the-backend-processor"},"The backend processor"),Object(o.b)("p",null,"Next, I design the ",Object(o.b)("strong",{parentName:"p"},"processor")," API, which contains all the same channels as the ",Object(o.b)("strong",{parentName:"p"},"game server"),", but with a different operation keyword. "),Object(o.b)("figure",null,Object(o.b)("img",{src:"/img/posts/jonaslagoni-miniseries-part1/blog-miniseries-processor-api.webp",title:"Processor setup"}),Object(o.b)("figcaption",{className:"text-center text-gray-400 text-sm"},'Displays the processor API as it is described with AsyncAPI with version 2.0.0. The round dot between "some broker" and the processor represent how others may grab/provide events that the processor subscribes to.')),Object(o.b)("p",null,"This is again because I need to define how others may interact with our ",Object(o.b)("strong",{parentName:"p"},"processor"),". This means that instead of using the ",Object(o.b)("inlineCode",{parentName:"p"},"subscribe")," operation I use ",Object(o.b)("inlineCode",{parentName:"p"},"publish")," to tell others that they can publish to this channel since the backend ",Object(o.b)("strong",{parentName:"p"},"processor")," is subscribing to it. The full AsyncAPI document for the ",Object(o.b)("strong",{parentName:"p"},"processor")," can be found ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jonaslagoni/asyncapi-miniseries/blob/master/AsyncAPI/Processor.yaml"}),"here"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"...\n  game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:\n    ...\n    publish: \n      ...\n...\n")),Object(o.b)("h2",{id:"introducing-reusability"},"Introducing reusability"),Object(o.b)("p",null,"At the moment, each of the AsyncAPI documents contains its definition of the channels. But what if I were to add a new validation rule such as a new property to the ",Object(o.b)("strong",{parentName:"p"},"playerItemPickupPayload"),Object(o.b)("undefined",{parentName:"p"}," schema? In this case, I would have to change this for both applications, which is way too much work ",Object(o.b)("span",{role:"img","aria-label":"smiling face with open mouth & smiling eyes"},"\ud83d\ude04"))),Object(o.b)("p",null,"Therefore, we can introduce ",Object(o.b)("strong",{parentName:"p"},"$ref")," to separate the parameters and messages into smaller sections for reusability. I will be placing all separate components into a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jonaslagoni/asyncapi-miniseries/tree/master/AsyncAPI"}),'"components" directory')," in the same directory the AsyncAPI documents reside."),Object(o.b)("p",null,"Just a quick note, at the moment, it is not possible to reuse channels and operations directly between the two applications. Therefore we can only apply this to the parameters and message individually while keeping some duplicate information ","[",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#channel-reusability"}),"2"),"]",". "),Object(o.b)("p",null,"First, I separate the different parameters. For simplicity, I add all of them into the same file ",Object(o.b)("inlineCode",{parentName:"p"},"./components/Parameters.yaml"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"serverId:\n  description: The id of the server\n  schema: \n    type: string\nplayerId:\n  description: The id of the player who performed the action\n  schema: \n    type: string\nitemId:\n  description: The id of the item\n  schema: \n    type: string\n")),Object(o.b)("p",null,"And then change all the channel parameters to reference the external parameter definition."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'...\n  game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:\n    description: Channel used when a player picks up an item in-game\n    parameters:\n      serverId: \n        $ref: "./components/Parameters.yaml#/serverId"\n      playerId: \n        $ref: "./components/Parameters.yaml#/playerId"\n      itemId: \n        $ref: "./components/Parameters.yaml#/itemId"\n    ...\n...\n')),Object(o.b)("p",null,"For the messages, I add a new file per message instead of keeping everything in the same file as parameters. I use this approach since I find it easier to maintain and extend."),Object(o.b)("p",null,"We add the message file ",Object(o.b)("inlineCode",{parentName:"p"},"./components/messages/PlayerItemPickup.yaml")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"payload:\n  type: object\n  properties:\n    pickupTimestamp:     \n      type: string\n      format: date-time\n      description: The timestamp the item was picked up\n  $id: PlayerItemPickupPayload\n  additionalProperties: false\n")),Object(o.b)("p",null,"and alter the channel definition for the ",Object(o.b)("strong",{parentName:"p"},"game server")," to:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'...\n  game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:\n    description: Channel used when a player picks up an item in-game\n    parameters:\n      serverId: \n        $ref: "./components/Parameters.yaml#/serverId"\n      playerId: \n        $ref: "./components/Parameters.yaml#/playerId"\n      itemId: \n        $ref: "./components/Parameters.yaml#/itemId"\n    subscribe: \n      message:\n        $ref: \'./components/messages/PlayerItemPickup.yaml\'\n...\n')),Object(o.b)("p",null,"These changes are applied to the ",Object(o.b)("strong",{parentName:"p"},"processor")," as well. You can find all the AsyncAPI files ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jonaslagoni/asyncapi-miniseries/tree/master/AsyncAPI"}),"here"),"."),Object(o.b)("h1",{id:"whats-next"},"What's next"),Object(o.b)("p",null,"Now, that the APIs are designed for two applications, we can move on to the fun part, implementing the applications using code generation."),Object(o.b)("h1",{id:"related-issues"},"Related issues"),Object(o.b)("p",null,"If you are interested in jumping into our discussions and being part of the community that drives the specification and tools, I have referenced some of the outstanding issues and discussions related to the different aspects I have referenced in the post."),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/asyncapi/spec/issues/390"}),"Add a View property to the info section to change the perspective of subscribe and publish operations")," ",Object(o.b)("a",{name:"view-property"})),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/asyncapi/spec/issues/415"}),"Reusing channel definitions across files is hard")," ",Object(o.b)("a",{name:"channel-reusability"})),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/asyncapi/spec/issues/520"}),"Confusions with the Publish and Subscribe meaning/perspective")," ",Object(o.b)("a",{name:"clarify-view"}))),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Cover photo by ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.pexels.com/@david-jakab-283330?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels"}),"David Jakab")," from ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.pexels.com/photo/galleon-ship-photo-under-the-cloudy-sky-1050656/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels"}),"Pexels"))))}l.isMDXComponent=!0},wx14:function(e,t,n){"use strict";function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}n.d(t,"a",(function(){return a}))}},[["MCFY",0,1]]]);