(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{"7ljp":function(e,n,t){"use strict";t.d(n,"a",(function(){return l})),t.d(n,"b",(function(){return h}));var s=t("q1tI"),o=t.n(s);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,s)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,s,o=function(e,n){if(null==e)return{};var t,s,o={},a=Object.keys(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var p=o.a.createContext({}),u=function(e){var n=o.a.useContext(p),t=n;return e&&(t="function"===typeof e?e(n):i(i({},n),e)),t},l=function(e){var n=u(e.components);return(o.a.createElement(p.Provider,{value:n},e.children))},b="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return(o.a.createElement(o.a.Fragment,{},n))}},d=o.a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,a=e.originalType,r=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),l=u(t),b=s,d=l["".concat(r,".").concat(b)]||l[b]||m[b]||a;return t?o.a.createElement(d,i(i({ref:n},p),{},{components:t})):o.a.createElement(d,i({ref:n},p))}));function h(e,n){var t=arguments,s=n&&n.mdxType;if("string"===typeof e||s){var a=t.length,r=new Array(a);r[0]=d;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i[b]="string"===typeof e?e:s,r[1]=i;for(var p=2;p<a;p++)r[p]=t[p];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},Ff2n:function(e,n,t){"use strict";function s(e,n){if(null==e)return{};var t,s,o=function(e,n){if(null==e)return{};var t,s,o={},a=Object.keys(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}t.d(n,"a",(function(){return s}))},GWK2:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/websocket-part2",function(){return t("cln0")}])},Qetd:function(e,n,t){"use strict";var s=Object.assign.bind(Object);e.exports=s,e.exports.default=e.exports},cln0:function(e,n,t){"use strict";t.r(n),t.d(n,"default",(function(){return b}));var s,o=t("wx14"),a=t("Ff2n"),r=t("q1tI"),i=t.n(r),c=t("7ljp"),p=(i.a.createElement,s="YouTube",function(e){return console.warn("Component "+s+" was not imported, exported, or provided by MDXProvider as global scope"),Object(c.b)("div",e)}),u={},l="wrapper";function b(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(c.b)(l,Object(o.a)({},u,t,{components:n,mdxType:"MDXLayout"}),Object(c.b)("blockquote",null,Object(c.b)("p",{parentName:"blockquote"}," This step-by-step guide is a continuation of a series of articles about WebSockets. I recommend reading ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"/blog/websocket-part1"}),"WebSocket, Shrek, and AsyncAPI - An Opinionated Intro")," first.")),Object(c.b)("p",null,"If you do not want to read this article, then watch the recording of the live stream about the same:"),Object(c.b)(p,{id:"8tFBcf31e_c",mdxType:"YouTube"}),Object(c.b)("p",null,"All roads lead to Rome, but all those roads are different. First, you need to identify where you are and what is the purpose of your journey. What is your goal? What do you want to use AsyncAPI for?"),Object(c.b)("p",null,"You may invest in using the specification for many different reasons, like for example:"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},"documentation"),Object(c.b)("li",{parentName:"ul"},"testing"),Object(c.b)("li",{parentName:"ul"},"mocking"),Object(c.b)("li",{parentName:"ul"},"code generation"),Object(c.b)("li",{parentName:"ul"},"message validation")),Object(c.b)("p",null,"Depending on your goal, you might need to take different roads to get there. If your only goal is documentation, you might take a different approach to writing an AsyncAPI file than you would take while thinking about code generation."),Object(c.b)("h2",{id:"choosing-the-right-road-to-rome"},"Choosing the right road to Rome"),Object(c.b)("p",null,"Let's say AsyncAPI does not fully cover your use case. You are missing some extra property. You are disappointed that you cannot explicitly provide information that your production servers both support different channels. Server A supports channel AA and AB, while Server B supports channel BA and BB. It is not currently possible with the specification as the assumption is that your application communicates with servers that support the same channels."),Object(c.b)("p",null,"There are two roads to Rome:"),Object(c.b)("p",null,"Road ",Object(c.b)("strong",{parentName:"p"},"docs-only"),": You need AsyncAPI for docs generation only and have no intention of sharing the source document with anyone. It means you do not need to bother much about inventing some specification extension. You can just add missing information to the description of a given object."),Object(c.b)("p",null,"Road ",Object(c.b)("strong",{parentName:"p"},"automation"),": You need AsyncAPI for docs and code generation, which means that all details in your AsyncAPI document must be machine-readable. You can't just put unsupported information in the description."),Object(c.b)("h2",{id:"kraken-api-use-case"},"Kraken API use case"),Object(c.b)("p",null,"I'm going to guide you through the process of creating an AsyncAPI document. I'll use the example of Kraken API mentioned in my ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"/blog/websocket-part1"}),"previous article"),"."),Object(c.b)("p",null,"The challenge I had here was that I'm trying to document an API basing on public docs with no access to a subject matter expert. I also have zero understanding of the cryptocurrency industry and still do not fully understand the vocabulary. "),Object(c.b)("blockquote",null,Object(c.b)("p",{parentName:"blockquote"},Object(c.b)("strong",{parentName:"p"},"Message to Kraken API developers and technical writers")," ",Object(c.b)("br",null),"\nIn case you want to continue the work I started on the AsyncAPI document for Kraken API, feel free to do that. I'm happy to help, just let me know. Reach me out in our ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"https://www.asyncapi.com/slack-invite/"}),"AsyncAPI Slack workspace"),".")),Object(c.b)("p",null,"More interesting here are the technical challenges though, caused by the fact that Kraken's API:"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},"has two production servers for non-secure and secure message exchange"),Object(c.b)("li",{parentName:"ul"},"some messages are supported only by the public and some only by a private server"),Object(c.b)("li",{parentName:"ul"},"has just one entry point for communication. You do not get specific messages from one of many endpoints. You get specific messages after first sending a subscription message. Meaning you have a request message and you get a reply message, so something that is not yet possible to describe with AsyncAPI in a machine-readable way")),Object(c.b)("h2",{id:"writing-a-single-asyncapi-document"},"Writing a single AsyncAPI document"),Object(c.b)("p",null,"Because of all these different challenges, I took the ",Object(c.b)("strong",{parentName:"p"},"docs-only")," road described in section ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"#choosing-the-right-road-to-rome"}),"Choosing the right road to Rome"),". No worries though, I give tips for the ",Object(c.b)("strong",{parentName:"p"},"automation")," road too."),Object(c.b)("h3",{id:"basic-information-about-the-api"},"Basic information about the API"),Object(c.b)("p",null,"First, provide some basic information that every good AsyncAPI file should have:"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},"What AsyncAPI version do you use?"),Object(c.b)("li",{parentName:"ul"},"What is the name of your API?"),Object(c.b)("li",{parentName:"ul"},"What version of the API you describe?"),Object(c.b)("li",{parentName:"ul"},"Do not underestimate the description. Optional != not needed. AsyncAPI supports markdown in descriptions. Provide long generic documentation for your API. Benefit from markdown features to structure it, so it is easier to read")),Object(c.b)("blockquote",null,Object(c.b)("p",{parentName:"blockquote"},Object(c.b)("undefined",{parentName:"p"},"In case you think using just one property to add overarching documentation for your API is very limiting, I agree with you ",Object(c.b)("span",{role:"img","aria-label":"smiling face with open mouth"},"\ud83d\ude03")," Join discussion "),Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/asyncapi/extensions-catalog/issues/11"}),"here"),". I believe spec should have better support for docs, and we should first explore it with specification extensions. To be honest, I always thought documentation deserves its specification, but I don't want to bother you with my wicked visions now.")),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yaml"}),"asyncapi: 2.0.0\ninfo:\n  title: Kraken Websockets API\n  version: '1.8'\n  description: |\n    WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint. \n\n    ### General Considerations\n\n    - TLS with SNI (Server Name Indication) is required in order to establish a Kraken WebSockets API connection. See Cloudflare's [What is SNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/) guide for more details.\n    - All messages sent and received via WebSockets are encoded in JSON format.\n    - All decimal fields (including timestamps) are quoted to preserve precision.\n    - Timestamps should not be considered unique and not be considered as aliases for transaction IDs. Also, the granularity of timestamps is not representative of transaction rates.\n    - At least one private message should be subscribed to keep the authenticated client connection open.\n    - Please use REST API endpoint [AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs) to fetch the list of pairs which can be subscribed via WebSockets API. For example, field 'wsname' gives the supported pairs name which can be used to subscribe.\n    - Cloudflare imposes a connection/re-connection rate limit (per IP address) of approximately 150 attempts per rolling 10 minutes. If this is exceeded, the IP is banned for 10 minutes.\n    - Recommended reconnection behaviour is to (1) attempt reconnection instantly up to a handful of times if the websocket is dropped randomly during normal operation but (2) after maintenance or extended downtime, attempt to reconnect no more quickly than once every 5 seconds. There is no advantage to reconnecting more rapidly after maintenance during cancel_only mode.\n")),Object(c.b)("h3",{id:"provide-server-information"},"Provide server information"),Object(c.b)("p",null,"Describe how to connect to the API:"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},"What is the URL of the server?"),Object(c.b)("li",{parentName:"ul"},"Is there any authorization in place?"),Object(c.b)("li",{parentName:"ul"},"What is the protocol requirement, is SSL connection required?")),Object(c.b)("p",null,"The Kraken API is an excellent example of how different WebSocket implementations can be and that there is never one way to design your architecture. It all depends on your requirements, the use cases that drive your product."),Object(c.b)("h4",{id:"describing-multiple-servers"},"Describing multiple servers"),Object(c.b)("p",null,"Below you can notice two different servers. These are not, as you might think, production and development servers. Here you have a clear division between publicly available data and private-only data. In other words, users use two different servers, not channels/paths/endpoints, to talk to the API."),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yaml"}),"servers:\n  public:\n    url: ws.kraken.com\n    protocol: wss\n    description: |\n      Public server available without authorization.\n      Once the socket is open you can subscribe to a public channel by sending a subscribe request message.\n  private:\n    url: ws-auth.kraken.com\n    protocol: wss\n    description: |\n      Private server that requires authorization.\n      Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.\n")),Object(c.b)("p",null,"You can verify if above is true by connecting to ",Object(c.b)("strong",{parentName:"p"},"ws.kraken.com")," and trying to subscribe to one of the event streams that require a token: "),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-json"}),'{ "event": "subscribe",  "subscription": { "name": "ownTrades", "token": "WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu" } }\n')),Object(c.b)("p",null,"In response you get an error:"),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-json"}),'{"errorMessage":"Private data and trading are unavailable on this endpoint. Try ws-auth.kraken.com","event":"subscriptionStatus","status":"error","subscription":{"name":"ownTrades","token":"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu"}}\n')),Object(c.b)("blockquote",null,Object(c.b)("p",{parentName:"blockquote"},"In the documentation, they also indicate beta servers like ",Object(c.b)("inlineCode",{parentName:"p"},"beta-ws.kraken.com"),". It is hard to understand their purpose, so I did not put them in the AsyncAPI document. For me, beta means something new, some upgrades, and I would consider writing a separate AsyncAPI document.")),Object(c.b)("p",null,"Is it reasonable to describe API that has two different production servers in one AsyncAPI? As usual, it depends. For ",Object(c.b)("strong",{parentName:"p"},"docs-only")," road described in section ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"#choosing-the-right-road-to-rome"}),"Choosing the right road to Rome"),', you can "workaround" some AsyncAPI features if they do not support your use case. Check out, for example, what I had to do in section ',Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"#server-security"}),"Server security")," where I was not sure how to describe the specific security of the private server. Short answer: just extend the description."),Object(c.b)("p",null,"For ",Object(c.b)("strong",{parentName:"p"},"automation")," road described in ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"#choosing-the-right-road-to-rome"}),"Choosing the right road to Rome")," section, you need a machine-readable structure. In case you have messages that can be consumed only by the ",Object(c.b)("strong",{parentName:"p"},"private")," server, you need a way to specify that the given message can be published only to the ",Object(c.b)("strong",{parentName:"p"},"private")," server. It is exactly the case with Kraken API."),Object(c.b)("p",null,"Imagine you want to read the AsyncAPI document in real-time in your server and validate all incoming messages. Take server ",Object(c.b)("strong",{parentName:"p"},"ws.kraken.com"),". The only way to emit errors like ",Object(c.b)("inlineCode",{parentName:"p"},"Private data and trading are unavailable on this endpoint. Try ws-auth.kraken.com")," is by writing the code that handles validation manually. You can't generate that as the AsyncAPI file does not specif what messages can go to ",Object(c.b)("strong",{parentName:"p"},"ws.kraken.com")," and what messages can't."),Object(c.b)("p",null,"Why?"),Object(c.b)("p",null,'At the moment, in AsyncAPI, you don\'t have a way to "wire" a server with a message, operation, or a channel. There are no default properties that allow you to provide information that message with the name ',Object(c.b)("strong",{parentName:"p"},"ownTrades")," can only be sent to ",Object(c.b)("inlineCode",{parentName:"p"},"ws-auth.kraken.com")," server."),Object(c.b)("p",null,"Solution?"),Object(c.b)("p",null,"Create two AsyncAPI documents. Treat those two servers as separate services that share messages and schemas. Use ",Object(c.b)("strong",{parentName:"p"},"$ref")," feature to ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"/blog/organizing-asyncapi-documents"}),"cross-reference schemas"),"."),Object(c.b)("h4",{id:"server-security"},"Server security"),Object(c.b)("p",null,"You can use AsyncAPI also to describe the security of your API. You can describe in a machine-readable way the security mechanism that protects the server. Several ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/asyncapi/spec/blob/master/spec/asyncapi.md#securitySchemeObject"}),"security schemes")," are supported. In Kraken's case, I could not figure out what kind of security scheme they use from their docs.  They seem to have a non-standard set up for getting the authorization token, which is why the only option was to put a human-readable-only description there."),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yaml"}),'servers:\n  public:\n    url: ws.kraken.com\n    protocol: wss\n    description: |\n      Public server available without authorization.\n      Once the socket is open, you can subscribe to a public channel by sending a subscribe request message.\n  private:\n    url: ws-auth.kraken.com\n    protocol: wss\n    description: |\n      Private server that requires authorization.\n      Once the socket is open, you can subscribe to private-data channels by sending an authenticated subscribe request message.\n\n      The API client must request an authentication "token" via the following REST API endpoint "GetWebSocketsToken" to connect to WebSockets Private endpoints. For more details, read https://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-3\n\n      The resulting token must be provided in the "token" field of any new private WebSocket feed subscription: \n      ```\n      {\n        "event": "subscribe",\n        "subscription":\n        {\n          "name": "ownTrades",\n          "token": "WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu"\n        }\n      }\n      ```\n')),Object(c.b)("h3",{id:"endpoints-aka-channels"},"Endpoints aka Channels"),Object(c.b)("p",null,"I saw WebSocket APIs that provide different streams of messages on separate endpoints. It is often the case when you build the WebSocket API for the frontend only and design it for different UI views. In the case of Kraken API we have no endpoints. You connect to the root of the server."),Object(c.b)("p",null,"No matter what setup you have, just remember you should use ",Object(c.b)("strong",{parentName:"p"},"channels")," to describe it. In the case of connecting to the root, it is as simple as:"),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yaml"}),"channels:\n  /:\n")),Object(c.b)("h3",{id:"multiple-different-messages-on-the-same-channel"},"Multiple different messages on the same channel"),Object(c.b)("p",null,"You can have one or many different messages coming to your channel. Like in the case of Kraken API, you can even have multiple messages, incoming and outgoing. You can describe it using ",Object(c.b)("strong",{parentName:"p"},"oneOf")," on ",Object(c.b)("strong",{parentName:"p"},"message")," object as you can see below:"),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yaml"}),"channels:\n  /:\n    publish:\n      operationId: sendMessage\n      message:\n        oneOf:\n          - $ref: '#/components/messages/ping'\n          - $ref: '#/components/messages/subscribe'\n          - $ref: '#/components/messages/unsubscribe'\n    subscribe:\n      operationId: processMessage\n      message:\n        oneOf:\n          - $ref: '#/components/messages/pong'\n          - $ref: '#/components/messages/heartbeat'\n          - $ref: '#/components/messages/systemStatus'\n          - $ref: '#/components/messages/subscriptionStatus'\n")),Object(c.b)("p",null,"Hold on! Where did these ",Object(c.b)("strong",{parentName:"p"},"publish")," and ",Object(c.b)("strong",{parentName:"p"},"subscribe")," keywords came from. "),Object(c.b)("p",null,"When we talk about WebSocket, we usually do not use words like subscribe and publish, as we do not think about producers and consumers. Just check out ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"https://tools.ietf.org/html/rfc6455"}),"the protocol RfC"),". We are used to ",Object(c.b)("strong",{parentName:"p"},"sending")," and ",Object(c.b)("strong",{parentName:"p"},"receiving")," messages."),Object(c.b)("p",null,Object(c.b)("undefined",{parentName:"p"},"Let me present to you an unofficial AsyncAPI vocabulary translator for WebSocket users ",Object(c.b)("span",{role:"img","aria-label":"smiling face with open mouth"},"\ud83d\ude03"))),Object(c.b)("table",null,Object(c.b)("thead",{parentName:"table"},Object(c.b)("tr",{parentName:"thead"},Object(c.b)("th",Object(o.a)({parentName:"tr"},{align:null}),"WebSocket term"),Object(c.b)("th",Object(o.a)({parentName:"tr"},{align:null}),"AsyncAPI term"),Object(c.b)("th",Object(o.a)({parentName:"tr"},{align:null}),"Meaning from API server perspective"),Object(c.b)("th",Object(o.a)({parentName:"tr"},{align:null}),"Meaning from API user perspective"))),Object(c.b)("tbody",{parentName:"table"},Object(c.b)("tr",{parentName:"tbody"},Object(c.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Send"),Object(c.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Publish"),Object(c.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"The API server receives the given message."),Object(c.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"The API user can send a given message to the API server.")),Object(c.b)("tr",{parentName:"tbody"},Object(c.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Receive"),Object(c.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Subscribe"),Object(c.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"The API server sends a given message."),Object(c.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"The API user can receive a given message from the API server.")))),Object(c.b)("h3",{id:"messages-definition"},"Messages definition"),Object(c.b)("p",null,"In event-driven architectures (EDA) it's all about the event, right? The message passed in the system. You need to specify many details about the message, like its payload structure, headers, purpose, and many others. "),Object(c.b)("p",null,"Above all, always remember to have good examples. Please don't count on the autogenerated ones, as in most cases, they're useless. "),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yml"}),"messages:\n  systemStatus:\n    description: Status sent on connection or system status changes.\n    payload:\n      $ref: '#/components/schemas/systemStatus'\n    examples:\n      - payload:\n          connectionID: 8628615390848610000\n          event: systemStatus\n          status: online\n          version: 1.0.0\n")),Object(c.b)("h3",{id:"describe-responses---specification-extensions"},"Describe responses - specification extensions"),Object(c.b)("p",null,"Describe responses? What responses? "),Object(c.b)("p",null,"It is EDA. Who cares about responses, right? Fire and forget rules!"),Object(c.b)("p",null,"The thing is that request and reply pattern is also used in EDA. This is also the case with Kraken API where communication goes through a single channel with multiple different messages. One message triggers another message in response."),Object(c.b)("p",null,"The simplest example is the message ",Object(c.b)("strong",{parentName:"p"},"ping")," that triggers a ",Object(c.b)("strong",{parentName:"p"},"pong")," reply. The current AsyncAPI limitation is that you cannot specify that once the user sends (publish) message ",Object(c.b)("strong",{parentName:"p"},"ping"),", the ",Object(c.b)("strong",{parentName:"p"},"pong")," message is received in a reply. Look at this ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/asyncapi/spec/issues/94"}),"thread")," to participate in an ongoing discussion about request/reply pattern support in AsyncAPI."),Object(c.b)("p",null,"For ",Object(c.b)("strong",{parentName:"p"},"docs-only")," road from section ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"#choosing-the-right-road-to-rome"}),"Choosing the right road to Rome"),", I would be lazy and just put such info in the description of both messages. Even though this is an error-prone approach, I would just make my life easier. For ",Object(c.b)("strong",{parentName:"p"},"automation")," road I would choose to use a specification extension."),Object(c.b)("p",null,"What is specification extension?"),Object(c.b)("p",null,"You can extend every AsyncAPI object in the AsyncAPI document with extra properties. You only need to prefix them with ",Object(c.b)("inlineCode",{parentName:"p"},"x-"),". You can also share extensions or reuse extensions from others thanks to ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/asyncapi/extensions-catalog"}),"extensions catalog"),"."),Object(c.b)("p",null,"In the below document, you will notice that for the request/reply pattern, I use AsyncAPI specification extensions called ",Object(c.b)("strong",{parentName:"p"},"x-response"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yml"}),"messages:\n  ping:\n    summary: Ping server to determine whether connection is alive\n    description: Client can ping server to determine whether connection is alive, server responds with pong. This is an application level ping as opposed to default ping in websockets standard which is server initiated\n    payload:\n      $ref: '#/components/schemas/ping'\n    x-response:\n      $ref: '#/components/messages/pong'\n")),Object(c.b)("p",null,"Even though the reference to another object is provided inside the extension that is not part of AsyncAPI, our parser will resolve it correctly. It means that under ",Object(c.b)("strong",{parentName:"p"},"x-response")," property, I will have access to the entire message object."),Object(c.b)("h3",{id:"schemas-vs-json-schema"},"Schemas vs JSON Schema"),Object(c.b)("p",null,"Because the message itself is most important in the entire EDA, you need to describe the message payload properly. "),Object(c.b)("p",null,"AsyncAPI allows you to provide payload information in different schema formats. The default format is AsyncAPI Schema that is a superset of JSON Schema. You can use others too, like Avro, for example."),Object(c.b)("p",null,"From the AsyncAPI document point of view, the most important is that you can reuse schemas. In other words, instead of providing data directly to the ",Object(c.b)("strong",{parentName:"p"},"payload")," object, you can ",Object(c.b)("strong",{parentName:"p"},"$ref")," them from ",Object(c.b)("strong",{parentName:"p"},"components.schemas")," or even an external document. Just DRY, right?"),Object(c.b)("p",null,"The rest, I would say, has nothing to do with AsyncAPI itself. How you structure schemas depends on you and the schema format that you use. It is why the next sections of my article describe something specific, not for the AsyncAPI itself but rather JSON Schema."),Object(c.b)("p",null,"Simplest example of schemas from Kraken API is a payload for ",Object(c.b)("strong",{parentName:"p"},"ping")," message:"),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yml"}),"schemas:\n  ping:\n    type: object\n    properties:\n      event:\n        type: string\n        const: ping\n      reqid:\n        $ref: '#/components/schemas/reqid'\n    required:\n      - event\n  reqid:\n    type: integer\n    description: client originated ID reflected in response message.\n")),Object(c.b)("p",null,"You can see that ",Object(c.b)("strong",{parentName:"p"},"ping")," message is an object that has two properties where only one is required. One property is used across other messages, so is part of many different schemas, so better to keep its definition as a separate schema and reference where needed."),Object(c.b)("h3",{id:"schemas-complexity"},"Schemas complexity"),Object(c.b)("p",null,"Splitting schemas into reusable chunks with ",Object(c.b)("strong",{parentName:"p"},"$ref")," usage is not something complex. It gets complex when messages are complex, when you get different message payload depending on system behavior."),Object(c.b)("p",null,"Kraken API has a ",Object(c.b)("strong",{parentName:"p"},"subscriptionStatus")," message where payload depends on the success of the subscription. In case of successful subscription, you get a message with ",Object(c.b)("strong",{parentName:"p"},"channelID")," and ",Object(c.b)("strong",{parentName:"p"},"channelName")," properties, but in case of failure, the message doesn't contain these properties but in exchange has ",Object(c.b)("strong",{parentName:"p"},"errorMessage"),". In other words, some properties are mutually exclusive."),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yml"}),"    subscriptionStatus:\n      type: object\n      oneOf:\n        - required:\n            - errorMessage\n          not:\n            required:\n                - channelID\n                - channelName\n        - required:\n            - channelID\n            - channelName\n          not:\n            required:\n                - errorMessage\n      properties:\n        channelID:\n          type: integer\n          description: ChannelID on successful subscription, applicable to public messages only.\n        channelName:\n          type: string\n          description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n        errorMessage:\n          type: string\n        event:\n          type: string\n          const: subscriptionStatus\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        status:\n          $ref: '#/components/schemas/status'\n        subscription:\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            maxratecount:\n              $ref: '#/components/schemas/maxratecount'\n            name:\n              $ref: '#/components/schemas/name'\n            token:\n              $ref: '#/components/schemas/token'\n          required:\n            - name\n      required:\n        - event\n")),Object(c.b)("p",null,"It is what I call a complex schema, where good JSON Schema knowledge is needed. The problem with complex schemas is that not many tools support these kinds of schemas. By the time I write this article, our AsyncAPI tools for documentation rendering will fail to render the above schema correctly."),Object(c.b)("p",null,"It is why you sometimes need compromises and adjusts schemas, so they get proper tooling support. Below you can see the same schema but structured in a more straightforward way supported by most tools."),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yml"}),"    subscriptionStatus:\n      type: object\n      oneOf:\n        - $ref: '#/components/schemas/subscriptionStatusError'\n        - $ref: '#/components/schemas/subscriptionStatusSuccess'\n    subscriptionStatusError:\n      allOf:\n        - properties:\n            errorMessage:\n              type: string\n          required:\n            - errorMessage\n        - $ref: '#/components/schemas/subscriptionStatusCommon'\n    subscriptionStatusSuccess:\n      allOf:\n        - properties:\n            channelID:\n              type: integer\n              description: ChannelID on successful subscription, applicable to public messages only.\n            channelName:\n              type: string\n              description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n          required:\n            - channelID\n            - channelName\n        - $ref: '#/components/schemas/subscriptionStatusCommon'\n    subscriptionStatusCommon:\n      type: object\n      required:\n         - event\n      properties:\n        event:\n          type: string\n          const: subscriptionStatus\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        status:\n          $ref: '#/components/schemas/status'\n        subscription:\n          required:\n            - name\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            maxratecount:\n              $ref: '#/components/schemas/maxratecount'\n            name:\n              $ref: '#/components/schemas/name'\n            token:\n              $ref: '#/components/schemas/token'\n")),Object(c.b)("p",null,"I managed to get a structure that will be nicely rendered in the UI. Even code generation will work well. It is a bit more complex than initial structure, although this is rather subjective personal-taste-like opinion."),Object(c.b)("h3",{id:"lets-have-a-look-at-the-final-document"},"Let's have a look at the final document"),Object(c.b)("p",null,"Websocket protocol is very flexible, and therefore you can implement the server in many different ways. The path that Kraken API took is complex but not impossible to describe with the AsyncAPI document. Look at the document's final structure and keep in mind that it is not a complete document for Kraken API and the road that I chose to get to Rome was to focus on documentation rendering only. "),Object(c.b)("p",null,"For ",Object(c.b)("strong",{parentName:"p"},"automation")," road described in section ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"#choosing-the-right-road-to-rome"}),"Choosing the right road to Rome"),", the document should be split into two documents: one for private and one for public servers. Common parts, like common messages and schemas, should be stored in separate files and referred from these two AsyncAPI documents using ",Object(c.b)("strong",{parentName:"p"},"$ref"),". Another solution would be to use specification extensions to describe relations between messages and servers."),Object(c.b)("blockquote",null,Object(c.b)("p",{parentName:"blockquote"},"You can open this document directly in Playground by clicking ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"https://playground.asyncapi.io?url=https://gist.githubusercontent.com/derberg/4e419d6ff5870c7c3f5f443e8bd30535/raw/5e9b733b80a0209ba5520e5f41ab18c2a112e0a9/asyncapi-websocket-kraken.yml"}),"this")," link. Compare it also with the ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"https://docs.kraken.com/websockets/"}),"oryginal documentation"),".")),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yml"}),"asyncapi: 2.0.0\n\ninfo:\n  title: Kraken Websockets API\n  version: '1.8.0'\n  description: |\n    WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint. \n\n    ### General Considerations\n\n    - TLS with SNI (Server Name Indication) is required in order to establish a Kraken WebSockets API connection. See Cloudflare's [What is SNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/) guide for more details.\n    - All messages sent and received via WebSockets are encoded in JSON format\n    - All decimal fields (including timestamps) are quoted to preserve precision.\n    - Timestamps should not be considered unique and not be considered as aliases for transaction IDs. Also, the granularity of timestamps is not representative of transaction rates.\n    - At least one private message should be subscribed to keep the authenticated client connection open.\n    - Please use REST API endpoint [AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs) to fetch the list of pairs which can be subscribed via WebSockets API. For example, field 'wsname' gives the supported pairs name which can be used to subscribe.\n    - Cloudflare imposes a connection/re-connection rate limit (per IP address) of approximately 150 attempts per rolling 10 minutes. If this is exceeded, the IP is banned for 10 minutes.\n    - Recommended reconnection behaviour is to (1) attempt reconnection instantly up to a handful of times if the websocket is dropped randomly during normal operation but (2) after maintenance or extended downtime, attempt to reconnect no more quickly than once every 5 seconds. There is no advantage to reconnecting more rapidly after maintenance during cancel_only mode.\n\nservers:\n  public:\n    url: ws.kraken.com\n    protocol: wss\n    description: |\n      Public server available without authorization.\n      Once the socket is open you can subscribe to a public channel by sending a subscribe request message.\n  private:\n    url: ws-auth.kraken.com\n    protocol: wss\n    description: |\n      Private server that requires authorization.\n      Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.\n\n      The API client must request an authentication \"token\" via the following REST API endpoint \"GetWebSocketsToken\" to connect to WebSockets Private endpoints. For more details read https://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-3\n\n      The resulting token must be provided in the \"token\" field of any new private WebSocket feed subscription: \n      ```\n      {\n        \"event\": \"subscribe\",\n        \"subscription\":\n        {\n          \"name\": \"ownTrades\",\n          \"token\": \"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\"\n        }\n      }\n      ```\n\nchannels:\n  /:\n    publish:\n      description: Send messages to the API\n      operationId: processReceivedMessage\n      message:\n        oneOf:\n          - $ref: '#/components/messages/ping'\n          - $ref: '#/components/messages/subscribe'\n          - $ref: '#/components/messages/unsubscribe'\n\n    subscribe:\n      description: Messages that you receive from the API\n      operationId: sendMessage\n      message:\n        oneOf:\n          - $ref: '#/components/messages/pong'\n          - $ref: '#/components/messages/heartbeat'\n          - $ref: '#/components/messages/systemStatus'\n          - $ref: '#/components/messages/subscriptionStatus'\n\ncomponents:\n  messages:\n    ping:\n      summary: Ping server to determine whether connection is alive\n      description: Client can ping server to determine whether connection is alive, server responds with pong. This is an application level ping as opposed to default ping in websockets standard which is server initiated\n      payload:\n        $ref: '#/components/schemas/ping'\n      x-response:\n        $ref: '#/components/messages/pong'\n    heartbeat:\n      description: Server heartbeat sent if no subscription traffic within 1 second (approximately)\n      payload:\n        $ref: '#/components/schemas/heartbeat'\n    pong:\n      summary: Pong is a response to ping message\n      description: Server pong response to a ping to determine whether connection is alive. This is an application level pong as opposed to default pong in websockets standard which is sent by client in response to a ping\n      payload:\n        $ref: '#/components/schemas/pong'\n    systemStatus:\n      description: Status sent on connection or system status changes.\n      payload:\n        $ref: '#/components/schemas/systemStatus'\n      examples:\n        - payload:\n            connectionID: 8628615390848610000\n            event: systemStatus\n            status: online\n            version: 1.0.0\n    subscribe:\n      description: Subscribe to a topic on a single or multiple currency pairs.\n      payload:\n        $ref: '#/components/schemas/subscribe'\n      examples:\n        - payload:\n            event: subscribe\n            pair:\n              - XBT/USD\n              - XBT/EUR\n            subscription:\n              name: ticker\n        - payload:\n            event: subscribe\n            subscription:\n              name: ownTrades\n              token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n      x-response:\n        $ref: '#/components/messages/subscriptionStatus'\n    unsubscribe:\n      description: Unsubscribe, can specify a channelID or multiple currency pairs.\n      payload:\n        $ref: '#/components/schemas/subscribe'\n      examples:\n        - payload:\n            event: unsubscribe\n            pair:\n              - XBT/EUR\n              - XBT/USD\n            subscription:\n              name: ticker\n        - payload:\n            event: unsubscribe\n            subscription:\n              name: ownTrades\n              token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n      x-response:\n        $ref: '#/components/messages/subscriptionStatus'\n    subscriptionStatus:\n      description: Subscription status response to subscribe, unsubscribe or exchange initiated unsubscribe.\n      payload:\n        $ref: '#/components/schemas/subscriptionStatus'\n      examples:\n        - payload:\n            channelID: 10001\n            channelName: ohlc-5\n            event: subscriptionStatus\n            pair: XBT/EUR\n            reqid: 42\n            status: unsubscribed\n            subscription:\n              interval: 5\n              name: ohlc\n        - payload:\n            errorMessage: Subscription depth not supported\n            event: subscriptionStatus\n            pair: XBT/USD\n            status: error\n            subscription:\n              depth: 42\n              name: book\n\n  schemas:\n    ping:\n      type: object\n      properties:\n        event:\n          type: string\n          const: ping\n        reqid:\n          $ref: '#/components/schemas/reqid'\n      required:\n        - event\n    heartbeat:\n      type: object\n      properties:\n        event:\n          type: string\n          const: heartbeat\n    pong:\n      type: object\n      properties:\n        event:\n          type: string\n          const: pong\n        reqid:\n          $ref: '#/components/schemas/reqid'\n    systemStatus:\n      type: object\n      properties:\n        event:\n          type: string\n          const: systemStatus\n        connectionID:\n          type: integer\n          description: The ID of the connection\n        status:\n          $ref: '#/components/schemas/status'\n        version:\n          type: string\n    status:\n      type: string\n      enum:\n        - online\n        - maintenance\n        - cancel_only\n        - limit_only\n        - post_only\n    subscribe:\n      type: object\n      properties:\n        event:\n          type: string\n          const: subscribe\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        subscription:\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            name:\n              $ref: '#/components/schemas/name'\n            ratecounter:\n              $ref: '#/components/schemas/ratecounter'\n            snapshot:\n              $ref: '#/components/schemas/snapshot'\n            token:\n              $ref: '#/components/schemas/token'\n          required:\n            - name\n      required:\n        - event\n    unsubscribe:\n      type: object\n      properties:\n        event:\n          type: string\n          const: unsubscribe\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        subscription:\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            name:\n              $ref: '#/components/schemas/name'\n            token:\n              $ref: '#/components/schemas/token'\n          required:\n            - name\n      required:\n        - event\n    subscriptionStatus:\n      type: object\n      oneOf:\n        - $ref: '#/components/schemas/subscriptionStatusError'\n        - $ref: '#/components/schemas/subscriptionStatusSuccess'\n    subscriptionStatusError:\n      allOf:\n        - properties:\n            errorMessage:\n              type: string\n          required:\n            - errorMessage\n        - $ref: '#/components/schemas/subscriptionStatusCommon'\n    subscriptionStatusSuccess:\n      allOf:\n        - properties:\n            channelID:\n              type: integer\n              description: ChannelID on successful subscription, applicable to public messages only.\n            channelName:\n              type: string\n              description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n          required:\n            - channelID\n            - channelName\n        - $ref: '#/components/schemas/subscriptionStatusCommon'\n    subscriptionStatusCommon:\n      type: object\n      required:\n         - event\n      properties:\n        event:\n          type: string\n          const: subscriptionStatus\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        status:\n          $ref: '#/components/schemas/status'\n        subscription:\n          required:\n            - name\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            maxratecount:\n              $ref: '#/components/schemas/maxratecount'\n            name:\n              $ref: '#/components/schemas/name'\n            token:\n              $ref: '#/components/schemas/token'\n    interval:\n      type: integer\n      description: Time interval associated with ohlc subscription in minutes.\n      default: 1\n      enum:\n        - 1\n        - 5\n        - 15\n        - 30\n        - 60\n        - 240\n        - 1440\n        - 10080\n        - 21600\n    name:\n      type: string\n      description: The name of the channel you subscribe too.\n      enum:\n        - book\n        - ohlc\n        - openOrders\n        - ownTrades\n        - spread\n        - ticker\n        - trade\n    token:\n      type: string\n      description: base64-encoded authentication token for private-data endpoints.\n    depth:\n      type: integer\n      default: 10\n      enum:\n        - 10\n        - 25\n        - 100\n        - 500\n        - 1000\n      description: Depth associated with book subscription in number of levels each side.\n    maxratecount:\n      type: integer\n      description: Max rate-limit budget. Compare to the ratecounter field in the openOrders updates to check whether you are approaching the rate limit.\n    ratecounter:\n      type: boolean\n      default: false\n      description: Whether to send rate-limit counter in updates (supported only for openOrders subscriptions)\n    snapshot:\n      type: boolean\n      default: true\n      description: Whether to send historical feed data snapshot upon subscription (supported only for ownTrades subscriptions)\n    reqid:\n      type: integer\n      description: client originated ID reflected in response message.\n    pair:\n      type: array\n      description: Array of currency pairs.\n      items:\n        type: string\n        description: Format of each pair is \"A/B\", where A and B are ISO 4217-A3 for standardized assets and popular unique symbol if not standardized.\n        pattern: '[A-Z\\s]+\\/[A-Z\\s]+'\n")),Object(c.b)("p",null,"Stay tuned for more articles around WebSocket and AsyncAPI. Share your feedback and connect with the AsyncAPI community in our ",Object(c.b)("a",Object(o.a)({parentName:"p"},{href:"https://www.asyncapi.com/slack-invite/"}),"Slack workspace"),"."))}b.isMDXComponent=!0},wx14:function(e,n,t){"use strict";function s(){return(s=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s])}return e}).apply(this,arguments)}t.d(n,"a",(function(){return s}))}},[["GWK2",0,1]]]);