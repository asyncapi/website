(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{"7ljp":function(e,t,n){"use strict";n.d(t,"a",(function(){return l})),n.d(t,"b",(function(){return d}));var s=n("q1tI"),o=n.n(s);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,s,o=function(e,t){if(null==e)return{};var n,s,o={},a=Object.keys(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=o.a.createContext({}),b=function(e){var t=o.a.useContext(p),n=t;return e&&(n="function"===typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=b(e.components);return(o.a.createElement(p.Provider,{value:t},e.children))},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return(o.a.createElement(o.a.Fragment,{},t))}},m=o.a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,a=e.originalType,r=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),l=b(n),u=s,m=l["".concat(r,".").concat(u)]||l[u]||h[u]||a;return n?o.a.createElement(m,i(i({ref:t},p),{},{components:n})):o.a.createElement(m,i({ref:t},p))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"===typeof e||s){var a=n.length,r=new Array(a);r[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[u]="string"===typeof e?e:s,r[1]=i;for(var p=2;p<a;p++)r[p]=n[p];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},Ff2n:function(e,t,n){"use strict";function s(e,t){if(null==e)return{};var n,s,o=function(e,t){if(null==e)return{};var n,s,o={},a=Object.keys(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}n.d(t,"a",(function(){return s}))},Qetd:function(e,t,n){"use strict";var s=Object.assign.bind(Object);e.exports=s,e.exports.default=e.exports},QrXr:function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return h}));var s=n("wx14"),o=n("Ff2n"),a=n("q1tI"),r=n.n(a),i=n("7ljp"),c=(r.a.createElement,function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),Object(i.b)("div",t)}}),p=c("YouTube"),b=c("Figure"),l={},u="wrapper";function h(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)(u,Object(s.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"This is a pretty subjective post. I'm sharing my perspective, taking into account years of experience building backend and frontend with user experience in mind. "),Object(i.b)("p",null,"If you do not want to read this article, then watch the recording of the live stream about the same:"),Object(i.b)(p,{id:"8tFBcf31e_c",mdxType:"YouTube"}),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"}," Everything we hear is an opinion, not a fact. Everything we see is a perspective, not the truth.\n\u2015 ",Object(i.b)("a",Object(s.a)({parentName:"p"},{href:"https://www.politifact.com/factchecks/2019/sep/26/viral-image/no-marcus-aurelius-didnt-say-about-opinions-and-fa/"}),"Marcus Aurelius"))),Object(i.b)("p",null,"This blog post is the first of a series of blog posts about WebSocket I'm working on."),Object(i.b)("h2",{id:"what-is-websocket"},"What is WebSocket"),Object(i.b)("p",null,"It is a pretty old protocol used for duplex communication over TCP connection. It was standardized in 2011. Yes, ten years ago means it is old, super old. "),Object(i.b)("p",null,"So why do I even mention it in 2021? "),Object(i.b)("p",null,"It is very widely adopted and will not go away anytime soon because tooling support is excellent and serves its purpose well. Just remind yourself when HTTP/2 showed up and how many years it took everyone to migrate. It would not happen without the strong support and push from all the big players. "),Object(i.b)("p",null,"Sure, there is ",Object(i.b)("a",Object(s.a)({parentName:"p"},{href:"https://developers.google.com/web/fundamentals/performance/http2/#request_and_response_multiplexing"}),"HTTP/2 multiplexing")," and protocols like ",Object(i.b)("a",Object(s.a)({parentName:"p"},{href:"https://mercure.rocks/docs/mercure"}),"Mercure")," or ",Object(i.b)("a",Object(s.a)({parentName:"p"},{href:"https://spec.graphql.org/June2018/#sec-Subscription"}),"GraphQL Subscription"),". There is also ",Object(i.b)("a",Object(s.a)({parentName:"p"},{href:"https://tools.ietf.org/html/rfc8441"}),"RFC8441")," for WebSocket and HTTP/2 and some tools already adopted it, like ",Object(i.b)("a",Object(s.a)({parentName:"p"},{href:"https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/upgrades"}),"Envoy")," or ",Object(i.b)("a",Object(s.a)({parentName:"p"},{href:"https://github.com/eclipse/jetty.project/issues/3537"}),"Jetty"),". Nevertheless, WebSocket is here to stay."),Object(i.b)("p",null,"Anyway, the future of WebSocket has nothing to do with this post. This post is for the AsyncAPI community looking into the AsyncAPI spec because of WebSockets now, no matter the protocol's future."),Object(i.b)("h2",{id:"websocket-use-case"},"Websocket use case"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Do you like to see in Slack that someone is typing a response? "),Object(i.b)("li",{parentName:"ul"},"Do you like it when a user interface updates without page refresh?"),Object(i.b)("li",{parentName:"ul"},"Do you like it when your client app knows there are updates available for display?")),Object(i.b)("p",null,"That is what WebSocket is for. You establish a long-living connection between client and server. Through such a connection, the client can send a stream of messages to the server, and this is possible the other way around at the same time."),Object(i.b)("p",null,"One could say: ",Object(i.b)("em",{parentName:"p"},"I don't need WebSocket to achieve that. I could just set up a data polling with REST API. Just ask the API every few seconds if there are updates.")),Object(i.b)("p",null,"Sadly this is not a joke. Engineers do it. Some engineers just take shortcuts, mostly because deadlines hunt them down."),Object(i.b)("p",null,"HTTP polling was presented very well in Shrek's famous ",Object(i.b)("em",{parentName:"p"},"Are we there yet?")," scene."),Object(i.b)(p,{id:"basofea2UEs",mdxType:"YouTube"}),Object(i.b)("p",null,"Don't go that path. Do not perform unnecessary connections to your servers and create more and more traffic with more and more resource consumption. Wasting resources is bad and makes Shrek angry. WebSocket changes a lot there:"),Object(i.b)(b,{src:"/img/posts/websocket-part1/websocket-shrek.webp",caption:"Figure 1: HTTP Pull vs WebSocket vs Shrek.",mdxType:"Figure"}),Object(i.b)("h2",{id:"why-asyncapi"},"Why AsyncAPI"),Object(i.b)("p",null,"When building a WebSocket API on a server, you might have some additional needs:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Want to document the API for the team that writes a client app, Web UI, Desktop app, or Mobile app. "),Object(i.b)("li",{parentName:"ul"},"Want to have a way to specify the format of the messages that the server supports to validate them in the runtime."),Object(i.b)("li",{parentName:"ul"},"Want to generate a server or/and a client? If not for final production use, then for sure for prototyping and testing.")),Object(i.b)("p",null,Object(i.b)("undefined",{parentName:"p"},"These are just a few common needs. For WebSocket, you only establish a connection over HTTP protocol, and the rest goes over WS, so OpenAPI specification won't help you much here. WebSocket is one of the patterns in event-based systems. In the end, it is all about a stream of messages and asynchronous processing. Yes, it would be best to use AsyncAPI ",Object(i.b)("span",{role:"img","aria-label":"smiling face with open mouth"},"\ud83d\ude03"))),Object(i.b)("h2",{id:"websocket-described-with-asyncapi"},"WebSocket described with AsyncAPI"),Object(i.b)("p",null,"When I google for some public WebSocket API to play with, I find mostly currency trading products:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(s.a)({parentName:"li"},{href:"https://docs.kraken.com/websockets/"}),"Kraken WebSocket API")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(s.a)({parentName:"li"},{href:"https://docs.gemini.com/websocket-api/"}),"Gemini WebSocket API")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(s.a)({parentName:"li"},{href:"https://cex.io/websocket-api"}),"CEXIO Websocket API"))),Object(i.b)("p",null,Object(i.b)("undefined",{parentName:"p"},"Currency trading is a topic I know nothing about ",Object(i.b)("span",{role:"img","aria-label":""},"\ud83e\udd37"),"\u200d\u2642 but it feels interesting to explore more. Documentation of the 1st and 2nd API looks familiar from look&feel perspective. I think we can make a bet they are already using AsyncAPI, and Kraken most probably is still running on version 1. Let's release the Kraken then.")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"I'm sorry if you expected me to describe Shrek's API interface using AsyncAPI. It would be fun, but only fun, and I'd also like to teach you something.")),Object(i.b)("p",null,"I will write an AsyncAPI document for Kraken API after playing with the API and basing it on the ",Object(i.b)("a",Object(s.a)({parentName:"p"},{href:"https://docs.kraken.com/websockets/"}),"current documentation"),"."),Object(i.b)("h3",{id:"playing-with-websocket-api"},"Playing with WebSocket API"),Object(i.b)("p",null,"The best way to play with a WebSocket API is through a CLI. Who didn't hear about ",Object(i.b)("strong",{parentName:"p"},"curl")," in the REST API world? For WebSocket, I would recommend ",Object(i.b)("strong",{parentName:"p"},"websocat"),". Kraken's API is partially public without authorization which is just great because to play with it, you do not have to set up an account to get an authorization token."),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Install ",Object(i.b)("strong",{parentName:"li"},"websocat"),". For other installation options, check out ",Object(i.b)("a",Object(s.a)({parentName:"li"},{href:"https://github.com/vi/websocat#installation"}),"this")," list.",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(s.a)({parentName:"pre"},{className:"language-sh"}),"brew install websocat\n"))),Object(i.b)("li",{parentName:"ol"},"Establish connection with the API:",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(s.a)({parentName:"pre"},{className:"language-sh"}),"websocat wss://ws.kraken.com\n"))),Object(i.b)("li",{parentName:"ol"},"Ping the API to see if it responds. Just type the below message and hit Enter:",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(s.a)({parentName:"pre"},{className:"language-json"}),'{"event": "ping"}\n'))),Object(i.b)("li",{parentName:"ol"},"Now subscribe to the event ",Object(i.b)("strong",{parentName:"li"},"ticker")," stream that sends messages with currency price. Just type the below message and hit Enter:",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(s.a)({parentName:"pre"},{className:"language-json"}),'{  "event": "subscribe",  "pair": [    "XBT/USD",    "XBT/EUR"  ],  "subscription": {    "name": "ticker"  }}\n'))),Object(i.b)("li",{parentName:"ol"},"You should now see a constant stream of data sent by the server. You do not have to ask the API every second for an update, as the update is pushed to you.",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(s.a)({parentName:"pre"},{className:"language-json"}),'{"event":"heartbeat"}\n[340,{"a":["45520.10000",6,"6.78103490"],"b":["45520.00000",0,"0.00185230"],"c":["45520.10000","0.01643250"],"v":["1397.95434819","5589.12101024"],"p":["44883.49461","44062.07654"],"t":[14350,66782],"l":["43607.60000","42770.80000"],"h":["45811.10000","45811.10000"],"o":["43659.30000","44709.10000"]},"ticker","XBT/EUR"]\n[340,{"a":["45520.10000",5,"5.84803490"],"b":["45492.50000",0,"0.09374582"],"c":["45492.50000","0.00625418"],"v":["1398.10526819","5589.26685876"],"p":["44883.56109","44062.11477"],"t":[14359,66790],"l":["43607.60000","42770.80000"],"h":["45811.10000","45811.10000"],"o":["43659.30000","44709.10000"]},"ticker","XBT/EUR"]\n{"event":"heartbeat"}\n[340,{"a":["45503.80000",1,"1.00000000"],"b":["45496.20000",0,"0.01426600"],"c":["45496.20000","0.00109400"],"v":["1398.10636219","5589.26295766"],"p":["44883.56157","44062.11447"],"t":[14360,66788],"l":["43607.60000","42770.80000"],"h":["45811.10000","45811.10000"],"o":["43659.30000","44709.90000"]},"ticker","XBT/EUR"]\n{"event":"heartbeat"}\n')))),Object(i.b)("p",null,Object(i.b)("undefined",{parentName:"p"},'Boy, it is always such fun to do it. Like seriously, I always have fun playing with APIs, any APIs. Just making this API "conversation". I hope nothing is wrong with me ',Object(i.b)("span",{role:"img","aria-label":"smiling face with open mouth & cold sweat"},"\ud83d\ude05"))),Object(i.b)("p",null,"Now you know how to interact with the Kraken API. Now let's try to describe it using AsyncAPI."),Object(i.b)("h3",{id:"describing-api-using-asyncapi"},"Describing API using AsyncAPI"),Object(i.b)("p",null,"I'll explain, in detail, how to describe Websocket API with AsyncAPI in another blog post that will be part of the series. Why? I don't want to make this post super lengthy and discourage others from reading it. Let us learn step by step. "),Object(i.b)("p",null,"For now, I will throw here a full AsyncAPI document I created for the Kraken API. You can also open it up in the ",Object(i.b)("a",Object(s.a)({parentName:"p"},{href:"https://playground.asyncapi.io?url=https://gist.githubusercontent.com/derberg/4e419d6ff5870c7c3f5f443e8bd30535/raw/5e9b733b80a0209ba5520e5f41ab18c2a112e0a9/asyncapi-websocket-kraken.yml"}),"AsyncAPI Playground")," and compare with their ",Object(i.b)("a",Object(s.a)({parentName:"p"},{href:"https://docs.kraken.com/websockets/"}),"current documentation")),Object(i.b)("p",null,"Familiarize with below before you look at the AsyncAPI document:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"AsyncAPI describes the API interface between the client and the server. In other words, the AsyncAPI document is for the user of the API. It does not describe what the server does but what the user can do with the API."),Object(i.b)("li",{parentName:"ul"},"Kraken API is quite complex. It has some beta servers, some private messages, and messages closely related to vocabulary specific for currency trading. I dropped all of those from my research not to overcomplicate things. In other words, the AsyncAPI file that you can see below is not a complete document."),Object(i.b)("li",{parentName:"ul"},"Websocket protocol is very flexible, and therefore you can implement the server in many different ways. There is no standard way of doing things, like there is no common way of doing things with AsyncAPI. We can only make some generic assumptions looking at existing implementations:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Your server has one entry point, just one endpoint that you communicate with to gain access to the API. It can be a ",Object(i.b)("a",Object(s.a)({parentName:"li"},{href:"https://ik.imagekit.io/ably/s3/xchg_products/async_api_specs/000/000/019/original/weather.yaml"}),"path with some dynamic values"),", as some data id. It can also be nothing, no path at all, like in the case of below Kraken API. These entry points are ",Object(i.b)("strong",{parentName:"li"},"channels")," in AsyncAPI document. Commonly, Websocket API has just one ",Object(i.b)("strong",{parentName:"li"},"channel")," that user can send messages to and receive messages at the same time"),Object(i.b)("li",{parentName:"ul"},"AsyncAPI publish and subscribe operations translates to ",Object(i.b)("strong",{parentName:"li"},"messages user can send to the API")," and ",Object(i.b)("strong",{parentName:"li"},"messages user will receive from the API"),". Depending on API complexity, sometimes you have an API that sends ",Object(i.b)("a",Object(s.a)({parentName:"li"},{href:"https://ik.imagekit.io/ably/s3/xchg_products/async_api_specs/000/000/019/original/weather.yaml"}),"only one message"),". You can also have a situation where you can send to the server multiple different messages, and also receive different messages in response. This is when you need to use ",Object(i.b)("strong",{parentName:"li"},"oneOf")," as I did in document for Kraken API."))),Object(i.b)("li",{parentName:"ul"},"Current AsyncAPI limitation is that you cannot specify that once the user sends (publish) message ",Object(i.b)("strong",{parentName:"li"},"ping"),", the ",Object(i.b)("strong",{parentName:"li"},"pong")," message is a reply. Look at this ",Object(i.b)("a",Object(s.a)({parentName:"li"},{href:"https://github.com/asyncapi/spec/issues/94"}),"thread")," to participate in an ongoing discussion about request/reply pattern support in AsyncAPI. In the below document, you will notice that for such a use case, I use AsyncAPI specification extensions (",Object(i.b)("strong",{parentName:"li"},"x-response"),").")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},Object(i.b)("strong",{parentName:"p"},"Message to Kraken API developers and technical writers")," ",Object(i.b)("br",null),"\nIn case you want to continue the work I started on the AsyncAPI document for Kraken API, feel free to do that. I'm happy to help, just let me know. Reach me out in our ",Object(i.b)("a",Object(s.a)({parentName:"p"},{href:"https://www.asyncapi.com/slack-invite/"}),"AsyncAPI Slack workspace"),".")),Object(i.b)("pre",null,Object(i.b)("code",Object(s.a)({parentName:"pre"},{className:"language-yml"}),"asyncapi: 2.0.0\n\ninfo:\n  title: Kraken Websockets API\n  version: '1.8.0'\n  description: |\n    WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint. \n\n    ### General Considerations\n\n    - TLS with SNI (Server Name Indication) is required in order to establish a Kraken WebSockets API connection. See Cloudflare's [What is SNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/) guide for more details.\n    - All messages sent and received via WebSockets are encoded in JSON format\n    - All decimal fields (including timestamps) are quoted to preserve precision.\n    - Timestamps should not be considered unique and not be considered as aliases for transaction IDs. Also, the granularity of timestamps is not representative of transaction rates.\n    - At least one private message should be subscribed to keep the authenticated client connection open.\n    - Please use REST API endpoint [AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs) to fetch the list of pairs which can be subscribed via WebSockets API. For example, field 'wsname' gives the supported pairs name which can be used to subscribe.\n    - Cloudflare imposes a connection/re-connection rate limit (per IP address) of approximately 150 attempts per rolling 10 minutes. If this is exceeded, the IP is banned for 10 minutes.\n    - Recommended reconnection behaviour is to (1) attempt reconnection instantly up to a handful of times if the websocket is dropped randomly during normal operation but (2) after maintenance or extended downtime, attempt to reconnect no more quickly than once every 5 seconds. There is no advantage to reconnecting more rapidly after maintenance during cancel_only mode.\n\nservers:\n  public:\n    url: ws.kraken.com\n    protocol: wss\n    description: |\n      Public server available without authorization.\n      Once the socket is open you can subscribe to a public channel by sending a subscribe request message.\n  private:\n    url: ws-auth.kraken.com\n    protocol: wss\n    description: |\n      Private server that requires authorization.\n      Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.\n\n      The API client must request an authentication \"token\" via the following REST API endpoint \"GetWebSocketsToken\" to connect to WebSockets Private endpoints. For more details read https://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-3\n\n      The resulting token must be provided in the \"token\" field of any new private WebSocket feed subscription: \n      ```\n      {\n        \"event\": \"subscribe\",\n        \"subscription\":\n        {\n          \"name\": \"ownTrades\",\n          \"token\": \"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\"\n        }\n      }\n      ```\n\nchannels:\n  /:\n    publish:\n      description: Send messages to the API\n      operationId: processReceivedMessage\n      message:\n        oneOf:\n          - $ref: '#/components/messages/ping'\n          - $ref: '#/components/messages/subscribe'\n          - $ref: '#/components/messages/unsubscribe'\n\n    subscribe:\n      description: Messages that you receive from the API\n      operationId: sendMessage\n      message:\n        oneOf:\n          - $ref: '#/components/messages/pong'\n          - $ref: '#/components/messages/heartbeat'\n          - $ref: '#/components/messages/systemStatus'\n          - $ref: '#/components/messages/subscriptionStatus'\n\ncomponents:\n  messages:\n    ping:\n      summary: Ping server to determine whether connection is alive\n      description: Client can ping server to determine whether connection is alive, server responds with pong. This is an application level ping as opposed to default ping in websockets standard which is server initiated\n      payload:\n        $ref: '#/components/schemas/ping'\n      x-response:\n        $ref: '#/components/messages/pong'\n    heartbeat:\n      description: Server heartbeat sent if no subscription traffic within 1 second (approximately)\n      payload:\n        $ref: '#/components/schemas/heartbeat'\n    pong:\n      summary: Pong is a response to ping message\n      description: Server pong response to a ping to determine whether connection is alive. This is an application level pong as opposed to default pong in websockets standard which is sent by client in response to a ping\n      payload:\n        $ref: '#/components/schemas/pong'\n    systemStatus:\n      description: Status sent on connection or system status changes.\n      payload:\n        $ref: '#/components/schemas/systemStatus'\n      examples:\n        - payload:\n            connectionID: 8628615390848610000\n            event: systemStatus\n            status: online\n            version: 1.0.0\n    subscribe:\n      description: Subscribe to a topic on a single or multiple currency pairs.\n      payload:\n        $ref: '#/components/schemas/subscribe'\n      examples:\n        - payload:\n            event: subscribe\n            pair:\n              - XBT/USD\n              - XBT/EUR\n            subscription:\n              name: ticker\n        - payload:\n            event: subscribe\n            subscription:\n              name: ownTrades\n              token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n      x-response:\n        $ref: '#/components/messages/subscriptionStatus'\n    unsubscribe:\n      description: Unsubscribe, can specify a channelID or multiple currency pairs.\n      payload:\n        $ref: '#/components/schemas/subscribe'\n      examples:\n        - payload:\n            event: unsubscribe\n            pair:\n              - XBT/EUR\n              - XBT/USD\n            subscription:\n              name: ticker\n        - payload:\n            event: unsubscribe\n            subscription:\n              name: ownTrades\n              token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n      x-response:\n        $ref: '#/components/messages/subscriptionStatus'\n    subscriptionStatus:\n      description: Subscription status response to subscribe, unsubscribe or exchange initiated unsubscribe.\n      payload:\n        $ref: '#/components/schemas/subscriptionStatus'\n      examples:\n        - payload:\n            channelID: 10001\n            channelName: ohlc-5\n            event: subscriptionStatus\n            pair: XBT/EUR\n            reqid: 42\n            status: unsubscribed\n            subscription:\n              interval: 5\n              name: ohlc\n        - payload:\n            errorMessage: Subscription depth not supported\n            event: subscriptionStatus\n            pair: XBT/USD\n            status: error\n            subscription:\n              depth: 42\n              name: book\n\n  schemas:\n    ping:\n      type: object\n      properties:\n        event:\n          type: string\n          const: ping\n        reqid:\n          $ref: '#/components/schemas/reqid'\n      required:\n        - event\n    heartbeat:\n      type: object\n      properties:\n        event:\n          type: string\n          const: heartbeat\n    pong:\n      type: object\n      properties:\n        event:\n          type: string\n          const: pong\n        reqid:\n          $ref: '#/components/schemas/reqid'\n    systemStatus:\n      type: object\n      properties:\n        event:\n          type: string\n          const: systemStatus\n        connectionID:\n          type: integer\n          description: The ID of the connection\n        status:\n          $ref: '#/components/schemas/status'\n        version:\n          type: string\n    status:\n      type: string\n      enum:\n        - online\n        - maintenance\n        - cancel_only\n        - limit_only\n        - post_only\n    subscribe:\n      type: object\n      properties:\n        event:\n          type: string\n          const: subscribe\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        subscription:\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            name:\n              $ref: '#/components/schemas/name'\n            ratecounter:\n              $ref: '#/components/schemas/ratecounter'\n            snapshot:\n              $ref: '#/components/schemas/snapshot'\n            token:\n              $ref: '#/components/schemas/token'\n          required:\n            - name\n      required:\n        - event\n    unsubscribe:\n      type: object\n      properties:\n        event:\n          type: string\n          const: unsubscribe\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        subscription:\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            name:\n              $ref: '#/components/schemas/name'\n            token:\n              $ref: '#/components/schemas/token'\n          required:\n            - name\n      required:\n        - event\n    subscriptionStatus:\n      type: object\n      oneOf:\n        - $ref: '#/components/schemas/subscriptionStatusError'\n        - $ref: '#/components/schemas/subscriptionStatusSuccess'\n    subscriptionStatusError:\n      allOf:\n        - properties:\n            errorMessage:\n              type: string\n          required:\n            - errorMessage\n        - $ref: '#/components/schemas/subscriptionStatusCommon'\n    subscriptionStatusSuccess:\n      allOf:\n        - properties:\n            channelID:\n              type: integer\n              description: ChannelID on successful subscription, applicable to public messages only.\n            channelName:\n              type: string\n              description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n          required:\n            - channelID\n            - channelName\n        - $ref: '#/components/schemas/subscriptionStatusCommon'\n    subscriptionStatusCommon:\n      type: object\n      required:\n         - event\n      properties:\n        event:\n          type: string\n          const: subscriptionStatus\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        status:\n          $ref: '#/components/schemas/status'\n        subscription:\n          required:\n            - name\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            maxratecount:\n              $ref: '#/components/schemas/maxratecount'\n            name:\n              $ref: '#/components/schemas/name'\n            token:\n              $ref: '#/components/schemas/token'\n    interval:\n      type: integer\n      description: Time interval associated with ohlc subscription in minutes.\n      default: 1\n      enum:\n        - 1\n        - 5\n        - 15\n        - 30\n        - 60\n        - 240\n        - 1440\n        - 10080\n        - 21600\n    name:\n      type: string\n      description: The name of the channel you subscribe too.\n      enum:\n        - book\n        - ohlc\n        - openOrders\n        - ownTrades\n        - spread\n        - ticker\n        - trade\n    token:\n      type: string\n      description: base64-encoded authentication token for private-data endpoints.\n    depth:\n      type: integer\n      default: 10\n      enum:\n        - 10\n        - 25\n        - 100\n        - 500\n        - 1000\n      description: Depth associated with book subscription in number of levels each side.\n    maxratecount:\n      type: integer\n      description: Max rate-limit budget. Compare to the ratecounter field in the openOrders updates to check whether you are approaching the rate limit.\n    ratecounter:\n      type: boolean\n      default: false\n      description: Whether to send rate-limit counter in updates (supported only for openOrders subscriptions)\n    snapshot:\n      type: boolean\n      default: true\n      description: Whether to send historical feed data snapshot upon subscription (supported only for ownTrades subscriptions)\n    reqid:\n      type: integer\n      description: client originated ID reflected in response message.\n    pair:\n      type: array\n      description: Array of currency pairs.\n      items:\n        type: string\n        description: Format of each pair is \"A/B\", where A and B are ISO 4217-A3 for standardized assets and popular unique symbol if not standardized.\n        pattern: '[A-Z\\s]+\\/[A-Z\\s]+'\n")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},Object(i.b)("strong",{parentName:"p"},"Personal note")," ",Object(i.b)("br",null),Object(i.b)("undefined",{parentName:"p"},"\nIf you can, if you are in a planning phase, new project, etc., then start designing your architecture with AsyncAPI. Don't do the mistake of coding first and then trying to figure out how to describe it with AsyncAPI ",Object(i.b)("span",{role:"img","aria-label":"smiling face with open mouth & cold sweat"},"\ud83d\ude05")))),Object(i.b)("p",null,Object(i.b)("undefined",{parentName:"p"},"Stay tuned for the next blog post that guides you step by step through the above document ",Object(i.b)("span",{role:"img","aria-label":"peace symbol"},"\u262e\ufe0f"))),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"I recommend you also read another article from the series about WebSocket: ",Object(i.b)("a",Object(s.a)({parentName:"p"},{href:"/blog/websocket-part2"}),"Creating AsyncAPI for WebSocket API - Step by Step"),".")))}h.isMDXComponent=!0},lnlK:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/websocket-part1",function(){return n("QrXr")}])},wx14:function(e,t,n){"use strict";function s(){return(s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(e[s]=n[s])}return e}).apply(this,arguments)}n.d(t,"a",(function(){return s}))}},[["lnlK",0,1]]]);