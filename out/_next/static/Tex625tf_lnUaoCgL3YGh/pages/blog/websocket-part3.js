(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{"7ljp":function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n("q1tI"),s=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=s.a.createContext({}),b=function(e){var t=s.a.useContext(l),n=t;return e&&(n="function"===typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=b(e.components);return(s.a.createElement(l.Provider,{value:t},e.children))},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return(s.a.createElement(s.a.Fragment,{},t))}},m=s.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=b(n),u=a,m=p["".concat(r,".").concat(u)]||p[u]||h[u]||o;return n?s.a.createElement(m,i(i({ref:t},l),{},{components:n})):s.a.createElement(m,i({ref:t},l))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"===typeof e||a){var o=n.length,r=new Array(o);r[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[u]="string"===typeof e?e:a,r[1]=i;for(var l=2;l<o;l++)r[l]=n[l];return s.a.createElement.apply(null,r)}return s.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},Ff2n:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}n.d(t,"a",(function(){return a}))},Qetd:function(e,t,n){"use strict";var a=Object.assign.bind(Object);e.exports=a,e.exports.default=e.exports},dKrE:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/websocket-part3",function(){return n("sCZl")}])},sCZl:function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return h}));var a=n("wx14"),s=n("Ff2n"),o=n("q1tI"),r=n.n(o),i=n("7ljp"),c=(r.a.createElement,function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),Object(i.b)("div",t)}}),l=c("Figure"),b=c("GeneratorInstallation"),p={},u="wrapper";function h(e){var t=e.components,n=Object(s.a)(e,["components"]);return Object(i.b)(u,Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"}," This is the last article of WebSocket series. I recommend you read ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/blog/websocket-part1"}),"WebSocket, Shrek, and AsyncAPI - An Opinionated Intro")," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/blog/websocket-part2"}),"Creating AsyncAPI for WebSocket API - Step by Step")," first.")),Object(i.b)("p",null,"In my previous articles from the WebSocket series, I introduced you to WebSocket topic and explained how you would describe your WebSocket API using AsyncAPI specification."),Object(i.b)("p",null,"What was the point of doing it anyway? Why learning the specification?"),Object(i.b)(l,{src:"/img/posts/websocket-part3/meme-newspec.webp",widthClass:"w-1/2",className:"text-center",mdxType:"Figure"}),Object(i.b)("p",null,"Just to document your API? Nah, that would be a huge waste of time. Like seriously, would you learn a new specification only to describe the API for documentation purposes? Please don't. You could do so much more with it."),Object(i.b)("p",null,"Look at the list of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.asyncapi.com/docs/community/tooling"}),"all the tools")," built for AsyncAPI. There are many ahead of us, but the current list already explains what can be done with AsyncAPI. You can validate your messages in real-time in your application with ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/WaleedAshraf/asyncapi-validator"}),"asyncapi-validator")," or mock and test your application with ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://microcks.io/"}),"Microcks"),". You can also generate code by picking one of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/asyncapi/generator#list-of-official-generator-templates"}),"the official templates"),". In this article, I will focus on the aspect of code generation."),Object(i.b)("h2",{id:"api-first-vs-code-first"},"API-First vs Code-First"),Object(i.b)("p",null,"Designing API first and then coding later is not an easy shift. For a coder, it is easier just to code and focus on code aspects. And this is just fine. That is how humans work. We do what we learned and focus on making things good and maintainable. Different tasks require different skills, and it is ok that not everybody has them. Designing API requires a different look on the subject, being more flexible and abstract. You need a wider perspective, forget about implementation details, and think about the user first."),Object(i.b)("p",null,"Do you need the specification to design API?"),Object(i.b)("p",null,"No, but specification makes the design process and feedback loop easier to handle and faster. If backed by good tools, of course."),Object(i.b)("p",null,"What is wrong with generating AsyncAPI from code?"),Object(i.b)("p",null,"Even though I'm an author of many memes like those in this article, I'm actually far from judging. It all depends on your project, architecture, and even the work environment. "),Object(i.b)(l,{src:"/img/posts/websocket-part3/meme-blame.webp",widthClass:"w-1/2",className:"text-center",mdxType:"Figure"}),Object(i.b)("p",null,"In the end, I think there is a wrong assumption that if you generate spec from code, it means you did not think about API design and your users. "),Object(i.b)("p",null,"Even AsyncAPI ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.asyncapi.com/docs/community/tooling"}),"tooling list")," stigmatize tools that allow you to generate spec from the code as code-first tools. Who said you couldn't do both things in parallel. "),Object(i.b)("p",null,"I just realized this topic could continue and evolve into a dedicated article, so let me do a full stop here. "),Object(i.b)("p",null,"My goal is to educate you on:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Designing a WebSocket API with multichannel, with one message each. In other words, I want to show you something opposite to my previous articles where you could see a WebSocket API that has one channel but with multiple different messages."),Object(i.b)("li",{parentName:"ul"},"Performing code generation that enables you to focus on business logic only.")),Object(i.b)("p",null,"I'll try to come back into ",Object(i.b)("strong",{parentName:"p"},"API-First vs Code-First")," topic in the summary of the article."),Object(i.b)("h2",{id:"shrekapp"},"ShrekApp"),Object(i.b)("p",null,"I know that in ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/blog/websocket-part1"}),"this article"),Object(i.b)("undefined",{parentName:"p"},", I wrote that I would not try to model a Shrek application. Since the moment I wrote I will not do it, I immediately started thinking about doing it ",Object(i.b)("span",{role:"img","aria-label":"smiling face with open mouth"},"\ud83d\ude03")," So here I am, showing you a possible use case for AsyncAPI with WebSocket protocol basing on Shrek. I shamefully admit I do it mainly to make sure my head moves on and thinks about something other than Shrek ",Object(i.b)("span",{role:"img","aria-label":"smiling face with open mouth"},"\ud83d\ude03"))),Object(i.b)("h2",{id:"write-asyncapi-document"},"Write AsyncAPI document"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"You can see entire AsyncAPI document ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/derberg/shrekapp-asyncapi-designed/blob/main/asyncapi.yaml"}),"here"))),Object(i.b)("p",null,"There are several questions you need to ask yourself when designing an API:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"What is the name of the API?"),Object(i.b)("li",{parentName:"ul"},"What is the purpose of the API?"),Object(i.b)("li",{parentName:"ul"},"What is the version of the API?"),Object(i.b)("li",{parentName:"ul"},"How user can connect with the API and over what protocol?"),Object(i.b)("li",{parentName:"ul"},"What messages can your user receive from and send to your API?"),Object(i.b)("li",{parentName:"ul"},"On what channels are these messages available?"),Object(i.b)("li",{parentName:"ul"},"What is the structure of these messages? What is the schema?")),Object(i.b)("p",null,"These are basic questions that can be reflected in the AsyncAPI document."),Object(i.b)("p",null,"In case you didn't notice, these questions are user-oriented. Your AsyncAPI document must describe what users can do with your application and not what it does. It makes a difference."),Object(i.b)("h3",{id:"info"},"Info"),Object(i.b)("p",null,"I'm designing a ",Object(i.b)("strong",{parentName:"p"},"ShrekApp"),", release under 1.0.0 version. Its purpose is to enable chat with a chatbot trained to behave like Shrek. I want to use ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://wit.ai"}),"Wit.ai")," as a platform for training the bot that gives me a REST API to talk to the bot."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yml"}),"info:\n  title: Shrek App\n  version: '1.0.0'\n  description: |\n    Purpose of this app is to have some fun with AsyncAPI and WebSocket and define an interface for ... Shrek.\n\n    ![](https://media.giphy.com/media/10Ug6rDDuG3YoU/giphy-downsized.gif)\n\n    You can use this API to chat with Shrek bot or to get updates about artifical travels to different locations.\n")),Object(i.b)("h3",{id:"servers"},"Servers"),Object(i.b)("p",null,"The communication with the application goes over the WebSocket protocol. For now, it is not publicly hosted. You can run it locally and therefore connect through ",Object(i.b)("strong",{parentName:"p"},"localhost")," only."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yml"}),"servers:\n  swamp:\n    url: localhost\n    protocol: ws\n")),Object(i.b)("h3",{id:"channels"},"Channels"),Object(i.b)("p",null,"There are two separate entry points for the user to interact with the API:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"chat")," where bi-directional communication is possible to enable real-time conversation with the bot"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"travel/status")," where user can subscribe for a stream of updates on different travels, like for example:",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yml"}),"  destination: Far far away\n  distance: Beyond the seven mountains and seven forests\n  arrival: Pretty soon\n")))),Object(i.b)("p",null,"Except for basic information like the purpose of messages, pub/sub operations, and messages schema, it is good to specify ",Object(i.b)("strong",{parentName:"p"},"operationId")," that is unique across the entire AsyncAPI document and helps to generate human-readable functions' names."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"In the below example, you can see a usage of ",Object(i.b)("strong",{parentName:"p"},"components")," section and schema definitions. I don't want to explain those sections in detail here as I did it already in the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/blog/websocket-part2"}),"Creating AsyncAPI for WebSocket API - Step by Step")," article.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yml"}),"#\n# Details about all the channels that user can listen to or send to messages\n#\nchannels:\n  /chat:\n    subscribe:\n      summary: Client can receive chat messages.\n      operationId: subChatMessage\n      message:\n        $ref: '#/components/messages/chatMessage'\n    publish:\n      summary: Client can send chat messages.\n      operationId: pubChatMessage\n      message:\n        $ref: '#/components/messages/chatMessage'\n  /travel/status:\n    subscribe:\n      summary: Client can receive travel info status.\n      operationId: subTravelInfo\n      message:\n        $ref: '#/components/messages/travelInfo'\n\n#\n# All reusable parts for readability and staying DRY\n#\ncomponents:\n  messages:\n    chatMessage:\n      summary: Message that you send or receive from chat\n      payload:\n        type: string\n    travelInfo:\n      summary: Message that contains information about travel status.\n      examples:\n        - payload:\n            destination: Far far away\n            distance: Beyond the seven mountains and seven forests\n            arrival: Pretty soon\n      payload:\n        type: object\n        properties:\n          destination:\n            description: Name of travel destination.\n            type: string\n          distance:\n            description: How much distance left to the target.\n            type: string\n          arrival:\n            description: Time left to get there.\n            type: string\n")),Object(i.b)("h3",{id:"final-document"},"Final document"),Object(i.b)("p",null,"You can see the entire AsyncAPI document for ShrekApp always up to date ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/derberg/shrekapp-asyncapi-designed/blob/main/asyncapi.yaml"}),"here")),Object(i.b)("p",null,"The AsyncAPI document I just created is not very complicated as this way it will be easier to understand the generated code. Most important is for you to notice that all information about your application is expressed in the AsyncAPI document, and once you do it, options for the next steps are just endless."),Object(i.b)("h2",{id:"generate-code"},"Generate Code"),Object(i.b)("p",null,"It is time now to generate some code that enables you to focus just on the business logic."),Object(i.b)("h3",{id:"asyncapi-generator"},"AsyncAPI Generator"),Object(i.b)("p",null,"The AsyncAPI Initiative maintains the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/asyncapi/generator/"}),"AsyncAPI Generator"),", a tool that enables you to generate anything you want out of an AsyncAPI document. ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.asyncapi.com/generator"}),"Generator")," provides several features that make it much easier to provide so-called ",Object(i.b)("strong",{parentName:"p"},"templates"),". The template is a standalone project that defines what files should be rendered by the Generator as a final output."),Object(i.b)("p",null,"We have many templates on our ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/asyncapi/generator#list-of-official-generator-templates"}),"list"),Object(i.b)("undefined",{parentName:"p"},". Try out the project by following ",Object(i.b)("span",{role:"img","aria-label":"backhand index pointing down"},"\ud83d\udc47")," instructions:")),Object(i.b)(b,{mdxType:"GeneratorInstallation"}),Object(i.b)("h3",{id:"generate-server-and-client"},"Generate Server and Client"),Object(i.b)("p",null,"This article focuses on WebSocket therefore, I use our ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/asyncapi/nodejs-ws-template"}),"Node.js WebSocket template")," that is capable of generating server for WebSocket API and also a client that is aware of available channels."),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Create a new directory where you will work on the project:",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"mkdir shrekapp && cd shrekapp\n"))),Object(i.b)("li",{parentName:"ol"},"Trigger generation using the template:",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"ag https://raw.githubusercontent.com/derberg/shrekapp-asyncapi-designed/main/asyncapi.yaml @asyncapi/nodejs-ws-template -o myapp -p server=swamp\n"))),Object(i.b)("li",{parentName:"ol"},"Access generated folder and list all files from the directory. Notice that Node.js application is generated:",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"cd myapp && ls\n"))),Object(i.b)("li",{parentName:"ol"},"Install application dependencies",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"npm i\n"))),Object(i.b)("li",{parentName:"ol"},"Start the application",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"npm start\n")))),Object(i.b)("p",null,"That is it. The basics are done. The application is ready, and all the basic logic is there. You can already interact with the application on ",Object(i.b)("strong",{parentName:"p"},"localhost")," on port ",Object(i.b)("strong",{parentName:"p"},"80"),". Now you need a client able to communicate with WebSocket protocol. For now, we will not explore the generated client."),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Get ",Object(i.b)("strong",{parentName:"p"},"websocat")," (curl-like tool for WebSocket) by following ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/vi/websocat#installation"}),"these instructions"))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Connect to one of the channels and notice that the server sent you a message to respond to established connection."),Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"websocat ws://localhost/travel/status\n\nMessage from the server: Implement here your business logic that sends messages to a client after it connects.\n")))),Object(i.b)("p",null,"Logs in the running server should also indicate a new connection with the server:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"Listening on port 80\n/travel/status client connected.\n")),Object(i.b)("h2",{id:"code-walkthrough"},"Code Walkthrough"),Object(i.b)("p",null,"Before writing some code, let's first go through the generated code:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"For the generated server, we need to look into ",Object(i.b)("inlineCode",{parentName:"li"},"src/api/routes.js")," and ",Object(i.b)("inlineCode",{parentName:"li"},"src/api/services")),Object(i.b)("li",{parentName:"ul"},"For generated client, everything is in the ",Object(i.b)("inlineCode",{parentName:"li"},"index.html"))),Object(i.b)("h3",{id:"server-code"},"Server Code"),Object(i.b)("h4",{id:"router"},"Router"),Object(i.b)("p",null,"Basing on the information provided in the AsyncAPI document about available channels, in the ",Object(i.b)("strong",{parentName:"p"},"src/api/routes.js")," the following routes are generated:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const { subChatMessage, pubChatMessage } = require('./services/chat');\nconst { subTravelInfo } = require('./services/travel-status');\n\nrouter.ws('/chat', async (ws, req) => {\n  const path = pathParser(req.path);\n  console.log(`${yellow(path)} client connected.`);\n  await subChatMessage(ws);\n  ws.on('message', async (msg) => {\n    console.log(`${yellow(path)} message was received:`);\n    console.log(util.inspect(msg, { depth: null, colors: true }));\n    await pubChatMessage(ws, { message: msg, path, query: req.query });\n  });\n});\nrouter.ws('/travel/status', async (ws, req) => {\n  const path = pathParser(req.path);\n  console.log(`${yellow(path)} client connected.`);\n  await subTravelInfo(ws);\n});\n")),Object(i.b)("p",null,"In the case of this particular template, routes are handled by ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://expressjs.com/"}),"Express framework")," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/HenningM/express-ws"}),"express-ws")," middleware."),Object(i.b)("p",null,"First let's have a look at ",Object(i.b)("strong",{parentName:"p"},"/travel/status")," route:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"router.ws('/travel/status', async (ws, req) => {\n  const path = pathParser(req.path);\n  console.log(`${yellow(path)} client connected.`);\n  await subTravelInfo(ws);\n});\n")),Object(i.b)("p",null,"Once the client establishes connection with the server, generated code invokes a function called ",Object(i.b)("strong",{parentName:"p"},"subTravelInfo"),". Now look again at the AsyncAPI document:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yml"}),"  /travel/status:\n    subscribe:\n      summary: Client can receive travel info status.\n      operationId: subTravelInfo\n      message:\n        $ref: '#/components/messages/travelInfo'\n")),Object(i.b)("p",null,"The name of the function maps to the ",Object(i.b)("strong",{parentName:"p"},"operationId"),". The ",Object(i.b)("strong",{parentName:"p"},"/travel/status")," channel supports only ",Object(i.b)("strong",{parentName:"p"},"subscribe")," operation which means that client can only connect to the channel to listen for the messages, no messages are accepted. This is why the generated router doesn't react to any message sent to the channel. As oposite to the ",Object(i.b)("strong",{parentName:"p"},"/chat")," channel:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"router.ws('/chat', async (ws, req) => {\n  const path = pathParser(req.path);\n  console.log(`${yellow(path)} client connected.`);\n  await subChatMessage(ws);\n  ws.on('message', async (msg) => {\n    console.log(`${yellow(path)} message was received:`);\n    console.log(util.inspect(msg, { depth: null, colors: true }));\n    await pubChatMessage(ws, { message: msg, path, query: req.query });\n  });\n});\n")),Object(i.b)("p",null,"The ",Object(i.b)("strong",{parentName:"p"},"subChatMessage")," function is invoked when client connects with the server. There is also a message listener generated that invokes ",Object(i.b)("strong",{parentName:"p"},"pubChatMessage")," function whenever a message is sent from the client. Now look again at the AsyncAPI document:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yml"}),"  /chat:\n    subscribe:\n      summary: Client can receive chat messages.\n      operationId: subChatMessage\n      message:\n        $ref: '#/components/messages/chatMessage'\n    publish:\n      summary: Client can send chat messages.\n      operationId: pubChatMessage\n      message:\n        $ref: '#/components/messages/chatMessage'\n")),Object(i.b)("p",null,"The client can not only listen to the messages incoming from ",Object(i.b)("inlineCode",{parentName:"p"},"/chat")," channel but, in this case, can also send messages. This way, there can be bi-directional communication established between the client and the chatbot."),Object(i.b)("h4",{id:"services"},"Services"),Object(i.b)("p",null,"Functions like, for example, ",Object(i.b)("strong",{parentName:"p"},"pubChatMessage")," are generated in the ",Object(i.b)("strong",{parentName:"p"},"services")," directory. All functions for single channel go into individual file. Have a look at ",Object(i.b)("strong",{parentName:"p"},"src/api/services/travel-status.js")," file:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const service = module.exports = {};\n\n/**\n * Client can receive travel info status.\n * @param {object} ws WebSocket connection.\n */\nservice.subTravelInfo = async (ws) => {\n  ws.send('Message from the server: Implement here your business logic that sends messages to a client after it connects.');\n};\n")),Object(i.b)("p",null,"As you can see, you are ready to provide your business logic by replacing the generated one:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"ws.send('Message from the server: Implement here your business logic that sends messages to a client after it connects.');\n")),Object(i.b)("h3",{id:"client-code"},"Client Code"),Object(i.b)("p",null,"The Node.js WebSocket template that I use for this article also generates ",Object(i.b)("strong",{parentName:"p"},"index.html")," file to showcase that client generation is also possible using AsyncAPI document. As I mentioned in the beginning, with AsyncAPI and the AsyncAPI Generator, you can generate whatever you want."),Object(i.b)("p",null,"The ",Object(i.b)("strong",{parentName:"p"},"index.html")," contains a simple API that you can call from the browser's console to talk to the WebSocket API. Open the file in the browser and play with the API:"),Object(i.b)(l,{src:"/img/posts/websocket-part3/client.webp",mdxType:"Figure"}),Object(i.b)("h2",{id:"add-business-logic"},"Add Business Logic"),Object(i.b)("p",null,"The Business logic goes only to generated services."),Object(i.b)("h3",{id:"add-travel-status-updates"},"Add Travel Status Updates"),Object(i.b)("p",null,"I don't have here any real travel status updates. I add some dummy data that are sent to the client every 1s, 100 times."),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Add ",Object(i.b)("strong",{parentName:"p"},"dummy-json")," that makes it easier to provide mock data. I add it only to make sure the code is not overcomplicated"),Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"npm i --save dummy-json\n"))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Imported the package in the ",Object(i.b)("strong",{parentName:"p"},"src/api/services/travel-status.js")," file:"),Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const dummyjson = require('dummy-json');\n"))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Modify ",Object(i.b)("strong",{parentName:"p"},"subTravelInfo")," from the same file to send mock data to the client with ",Object(i.b)("strong",{parentName:"p"},"ws.send()")," function:"),Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'service.subTravelInfo = async (ws) => {\n  (function myLoop (i) {\n    setTimeout(() => {\n      ws.send(generateResponse());\n      if (--i) myLoop(i);\n    }, 1000);\n  }(100));  \n\n  function generateResponse() {\n    const template = `{\n      "destination": "{{city}}",\n      "arrival": "{{int 2 6}}h",\n      "distance": "{{int 18 65}}km"\n    }`;\n    return dummyjson.parse(template);\n  }\n};\n')))),Object(i.b)("p",null,"This is it. Now restart the server and check with previously installed ",Object(i.b)("strong",{parentName:"p"},"websocat")," if after connecting to ",Object(i.b)("strong",{parentName:"p"},"travel/status")," channel you are now regularly receiving a stream of messages:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'websocat ws://localhost/travel/status\n\n{       "destination": "Woodville",       "arrival": "4h",       "distance": "60km"     }\n{       "destination": "Denver",       "arrival": "3h",       "distance": "60km"     }\n{       "destination": "Fargo",       "arrival": "3h",       "distance": "42km"     }\n{       "destination": "Exeter",       "arrival": "2h",       "distance": "62km"     }\n{       "destination": "Bradford",       "arrival": "2h",       "distance": "55km"     }\n{       "destination": "Toronto",       "arrival": "6h",       "distance": "28km"     }\n{       "destination": "Durham",       "arrival": "5h",       "distance": "59km"     }\n{       "destination": "Canterbury",       "arrival": "4h",       "distance": "50km"     }\n')),Object(i.b)("h3",{id:"add-chatbot-communication"},"Add ChatBot Communication"),Object(i.b)("p",null,"I chose Wit.ai as a platform that:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Makes is super easy to train the bot"),Object(i.b)("li",{parentName:"ul"},"Gives me access to API that enables integration with custom services, like the one that we just generated")),Object(i.b)("p",null,"I encourage you to ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://wit.ai/docs/quickstart"}),"give it a try")," as it is pretty easy to use if it is your first time with ChatBots. It was my first time. "),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"To make it easier to talk to Wit.ai API I use ",Object(i.b)("strong",{parentName:"p"},"node-fetch")," package:"),Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"npm i --save node-fetch\n"))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Imported the package in the ",Object(i.b)("strong",{parentName:"p"},"src/api/services/chat.js")," file:"),Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const fetch = require('node-fetch');\n"))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Modify ",Object(i.b)("strong",{parentName:"p"},"subChatMessage")," from the same file to send to the client message that connection is working:"),Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"service.subChatMessage = async (ws) => {\n  ws.send('Connection with Shrek established');\n};\n"))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Modify ",Object(i.b)("strong",{parentName:"p"},"pubChatMessage")," that is invoked when message from the client gets to the ",Object(i.b)("strong",{parentName:"p"},"/chat")," channel:"),Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"service.pubChatMessage = async (ws, { message, path, query }) => {\n  const messageToShrek = message ? encodeURIComponent(message) : '';\n  const defaultAnswer = 'Shrek is out sorry. He\\'s busy rescuing the princess.';\n  let shrekAnswer = defaultAnswer;\n  let botAnswer;\n\n  try {\n      botAnswer = await fetch(`https://api.wit.ai/message?q=${messageToShrek}`, {\n          headers: { 'Authorization': `Bearer ${process.env.CHATBOT_TOKEN}` }\n      });\n  } catch (e) {\n      throw new Error(`Having issues communicating with the bot: ${e}`);\n  }\n\n  if (botAnswer) {\n      const wrongQuestionAnswer = 'Is it you Donkey!? Ask a better question!';\n      const answerObject = await botAnswer.json();\n      let firstTraitValue;\n      \n      for (const [, v] of Object.entries(answerObject.traits)) {\n        firstTraitValue = v[0].value;\n        break;\n      }\n\n      shrekAnswer = firstTraitValue ? firstTraitValue : wrongQuestionAnswer;\n  }\n  console.log(`Answered with: ${shrekAnswer}`)\n  ws.send(shrekAnswer);\n};\n")))),Object(i.b)("p",null,"The most important part of this code is when the communication with the Wit.ai platform happens to send a message and get a response:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"      botAnswer = await fetch(`https://api.wit.ai/message?q=${messageToShrek}`, {\n          headers: { 'Authorization': `Bearer ${process.env.CHATBOT_TOKEN}` }\n      });\n")),Object(i.b)("p",null,"This is it. Now restart the server and check with previously installed ",Object(i.b)("strong",{parentName:"p"},"websocat")," if after connecting to ",Object(i.b)("strong",{parentName:"p"},"chat")," channel you can send messages to chatbot and receive answers. You need to start the server with ",Object(i.b)("strong",{parentName:"p"},"CHATBOT_TOKEN")," environment variable with the token: ",Object(i.b)("inlineCode",{parentName:"p"},"CHATBOT_TOKEN=your-token npm start"),". I cannot give you my token, sorry, you have to get yours from ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.wit.ai"}),"Wit.ai")," and train your chatbot:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"websocat ws://localhost/chat\n\nConnection with Shrek established\n\nMe: Hi Shrek\nShrek: hey, do you know ogrs have layers?\nMe: Interesting\nShrek: are you mocking me?\nMe: Why would I? I like you\nShrek: Is it you Donkey!? Ask a better question!\nMe: No, not a donkey\nShrek: good\n")),Object(i.b)("p",null,"You can also see logs on the server-side:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"Listening on port 80\n/chat client connected.\n/chat message was received:\n'Hi Shrek\\n'\nAnswered with: hey, do you know ogrs have layers?\n/chat message was received:\n'Interesting\\n'\nAnswered with: are you mocking me?\n/chat message was received:\n'Why would I? I like you\\n'\nAnswered with: Is it you Donkey!? Ask a better question!\n/chat message was received:\n'No, not a donkey\\n'\nAnswered with: good\n")),Object(i.b)("h2",{id:"summary"},"Summary"),Object(i.b)("p",null,"If you do not want to go through all the steps of getting the generated code, you can directly use ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/derberg/shrekapp-asyncapi-designed"}),"this project"),". It contains everything mentioned in this article."),Object(i.b)("p",null,"As you could see, the only coding part was just business implementation details, and the rest was generated. When I worked on this article, I focused first on the API. My main goal was to write the AsyncAPI document first, and the rest was easy."),Object(i.b)("p",null,"Are you convinced now that API-first is better than code-first?"),Object(i.b)(l,{src:"/img/posts/websocket-part3/meme-redbuttons.webp",widthClass:"w-1/2",className:"text-center",mdxType:"Figure"}),Object(i.b)("p",null,"I'm an API-first person. I can go on and give you many arguments that support my view."),Object(i.b)("p",null,"I won't do it."),Object(i.b)("p",null,"Instead, I will honestly tell you what the problems are related to API-first and code generation. You judge what is the path you want to take."),Object(i.b)("h3",{id:"asyncapi-20-limitations"},"AsyncAPI 2.0 Limitations"),Object(i.b)("p",null,"As I mention in this article and the previous ones on WebSocket, you write AsyncAPI document for your application from a client perspective. When you start designing your API, you ask yourself questions from the user's perspective."),Object(i.b)("p",null,"Don't get me wrong; I'm not saying that taking user perspective is wrong. It makes sense but also confusing for many. I recommend joining ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/asyncapi/spec/issues/520"}),"this thread")," for more details."),Object(i.b)("p",null,"Confusion between ",Object(i.b)("strong",{parentName:"p"},"subscribe")," and ",Object(i.b)("strong",{parentName:"p"},"publish")," is not the only problem. Once you understand that your application that publishes events must describe it as subscribe operation, the rest is trivial."),Object(i.b)("p",null,"The real problem is with code generation. You describe the application from a user perspective, so client code generation is easy. What about generating code for your server? Have a look again at the ",Object(i.b)("strong",{parentName:"p"},"/travel/status")," channel from ShrekApp:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yml"}),"  /travel/status:\n    subscribe:\n      summary: Client can receive travel info status.\n      operationId: subTravelInfo\n      message:\n        $ref: '#/components/messages/travelInfo'\n")),Object(i.b)("p",null,"I had to try hard to make sure the ",Object(i.b)("strong",{parentName:"p"},"summary")," and ",Object(i.b)("strong",{parentName:"p"},"operationId")," are as neutral as possible. My first version looked like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yml"}),"  /travel/status:\n    subscribe:\n      summary: You can listen to travel info status.\n      operationId: onTravelInfo #client code perspective, generated client reacts \"onTravelInfo\" incomming message \n      message:\n        $ref: '#/components/messages/travelInfo'\n")),Object(i.b)("p",null,"Then in ",Object(i.b)("strong",{parentName:"p"},"src/api/services/travel-status.js")," file, I would have ",Object(i.b)("strong",{parentName:"p"},"onTravelInfo")," instead of ",Object(i.b)("strong",{parentName:"p"},"subTravelInfo")," with the following jsdoc:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"/**\n * You can listen to travel info status.\n * @param {object} ws WebSocket connection.\n */\nservice.onTravelInfo = async (ws) => {\n...\n")),Object(i.b)("p",null,"This is a function responsible for sending messages to the Client once it connects with a given channel. Function name like ",Object(i.b)("strong",{parentName:"p"},"onTravelInfo")," is misleading, not to mention the generated code description."),Object(i.b)("p",null,'I chose neutral descriptions. They are acceptable, I think, but not when it comes to user-facing documentation. Every technical writer will tell you that the best docs are the ones that are directed to a reader. You don\'t write "what user can do with the API" but "what you can do with the API".'),Object(i.b)("p",null,"Therefore, all descriptions and even things like ",Object(i.b)("strong",{parentName:"p"},"operationId")," should have two versions to satisfy both docs and code depending on the perspective. Otherwise, you need to make a sacrifice. You either make the developer that maintains the code happy or the technical writer that maintains docs happy."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Join the discussion around ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/asyncapi/spec/issues/538"}),"operationId"),".")),Object(i.b)("h3",{id:"keeping-asyncapi-in-sync-with-code"},"Keeping AsyncAPI in Sync With Code"),Object(i.b)("p",null,"In this article, I generated a server that was easy to extend, to showcase AsyncAPI capabilities. Using such projects is a way for building prototypes and quickly design architectures. You can even scaffold a server that later you can tune and use on production."),Object(i.b)("p",null,"You did your work, you did API-first."),Object(i.b)("p",null,"What happens later? I mean later during further development of the application."),Object(i.b)("p",null,"Let's say you add a new channel to the server or modify the name of the old channel. "),Object(i.b)("p",null,"Where do you do it? AsyncAPI document or the code? You need to do it manually in both. You need to add a channel to the AsyncAPI document and add implementation for the channel in the code. You enter the land where your AsyncAPI document describes something different from your code at some point in time. You cannot regenerate the project with the template you used in the beginning, as your custom logic will be lost."),Object(i.b)("p",null,"The AsyncAPI Generator provides support for Git. If you have a Git repository and unstaged files, the Generator warns you that your changes may be lost. Git support is definitely helpful. You can try code regeneration, but you need to review changes and manually ignore overrides after that. "),Object(i.b)("p",null,"It can be a cumbersome process, but you maintain sync between the AsyncAPI document and the code. There is no place for automation, though."),Object(i.b)("p",null,"There must be a way to solve these challenges. Maybe some kind of markers.  One could use them in code to indicate that the generator must ignore a given part of the code. Another helpful solution could be a way to specify what template files should be ignored during generation. For example, regenerate only models built from messages' schemas. We need to figure it out."),Object(i.b)("p",null,"Don't give up, though. Technical challenges are not a good excuse for avoiding the API-first approach."),Object(i.b)(l,{src:"/img/posts/websocket-part3/meme-starwars.webp",widthClass:"w-1/2",className:"text-center",mdxType:"Figure"}),Object(i.b)("p",null,"In my opinion, specification limitations and gaps in tooling support should not block you from choosing an API-first direction. The benefits are too big to resign that easily. Just join us and let us find solutions together. We want to help solve all those issues, but we just need some help from you too."),Object(i.b)("p",null,"That would be it. Thanks for staying with me until the end. Don't forget to read my previous articles on AsyncAPI spec and WebSocket protocol. Share your feedback and connect with the AsyncAPI community in our ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.asyncapi.com/slack-invite/"}),"Slack workspace"),"."))}h.isMDXComponent=!0},wx14:function(e,t,n){"use strict";function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}n.d(t,"a",(function(){return a}))}},[["dKrE",0,1]]]);