(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{"5MvJ":function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return u}));var o=n("wx14"),r=n("Ff2n"),a=n("q1tI"),i=n.n(a),s=n("7ljp"),c=(i.a.createElement,{}),l="wrapper";function u(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(s.b)(l,Object(o.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("p",null,"A recurring question that I get very often is: \u201chow do I organize my AsyncAPI documents?\u201d. Also, the related one: \u201cI have two services, a publisher and a consumer, should I define both in the same AsyncAPI document?\u201d."),Object(s.b)("p",null,"Let\u2019s break down some best practices and tips to avoid ending up in a hell of unmanageable documents."),Object(s.b)("h2",{id:"organizing-microservices"},"Organizing Microservices"),Object(s.b)("blockquote",null,Object(s.b)("p",{parentName:"blockquote"},"I\u2019m using the term microservices here because it\u2019s the most common type of distributed architecture that you can find nowadays.")),Object(s.b)("p",null,"The best practice for organizing AsyncAPI files in your microservices architecture is to have a file per microservice. This way, you end up with multiple independent files that define your application."),Object(s.b)("figure",null,Object(s.b)("img",{src:"/img/posts/organizing-asyncapi-documents-1.webp",title:"One publisher and one subscriber, both sharing the UserSignUp message."}),Object(s.b)("figcaption",{className:"text-center text-gray-400 text-sm"},"One publisher and one subscriber, both sharing the UserSignUp message.")),Object(s.b)("p",null,"Microservices are meant to do a single thing and to do it well and, very importantly, they must be independently deployable. However, if you have a publisher and multiple consumers, you quickly end up having something like the following:"),Object(s.b)("figure",null,Object(s.b)("img",{src:"/img/posts/organizing-asyncapi-documents-2.webp",title:"One publisher and various subscribers. All of them sharing the UserSignUp message."}),Object(s.b)("figcaption",{className:"text-center text-gray-400 text-sm"},"One publisher and various subscribers. All of them sharing the UserSignUp message.")),Object(s.b)("p",null,"It\u2019s clear there\u2019s a dependency between all of them: the ",Object(s.b)("em",{parentName:"p"},"UserSignedUp")," message. If at some point to want to change it, you\u2019ll have to go through all of the files and change it. It\u2019s a tedious task we want to avoid, so we can make use of the ",Object(s.b)("em",{parentName:"p"},"$ref")," capability of AsyncAPI to simplify things:"),Object(s.b)("figure",null,Object(s.b)("img",{src:"/img/posts/organizing-asyncapi-documents-3.webp",title:"The value of $ref should be \u201ccommon/messages.json#UserSignedUp\u201d."}),Object(s.b)("figcaption",{className:"text-center text-gray-400 text-sm"},"The value of $ref should be \u201ccommon/messages.json#UserSignedUp\u201d.")),Object(s.b)("p",null,"Now, if you have to add something to the ",Object(s.b)("em",{parentName:"p"},"UserSignedUp")," message, it\u2019s just a matter of changing one file. Depending on your setup, you may have to restart your services to get the new definition. However, as simple and straightforward as it may seem, you must take care not to introduce breaking changes in the message definition. Otherwise, you\u2019ll have inconsistent states while some services got the new message definition and some didn\u2019t yet. Here comes the importance of versioning your messages, but that makes for another blog post alone."),Object(s.b)("h3",{id:"common-mistakes"},"Common mistakes"),Object(s.b)("p",null,"Since microservices tend to be small in scope, most probably their AsyncAPI document will not be very extensive too. And I found out this is one of the reasons people tend to re-use the same file for many services. They think the file is very small and because the publisher and the subscriber share the same message, why not putting everything there? It\u2019s tempting at first, but the reason why you should avoid doing this is that you lose context and semantics, and it causes problems:"),Object(s.b)("ol",null,Object(s.b)("li",{parentName:"ol"},"If a single document contains publish and subscribe for the same channel (topic), how do you know which one is defining what your application does?"),Object(s.b)("li",{parentName:"ol"},"Since your document may contain many channels, how do you know if your application is publishing or subscribing to each channel or just a subset of them? That itself causes more problems, for instance, when you want to generate the documentation for a single service but you have a single file defining your whole architecture and thus a single documentation page describing all the services without any clue which one is doing what.")),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"An AsyncAPI file is meant to define the behavior of a single application"),". You can obviously break the rules and use it to define the whole architecture but expect all sorts of problems to appear because you\u2019re using a hammer to saw a piece of wood. The same way you don\u2019t use a single OpenAPI (Swagger) file to define many of your REST APIs, you shouldn\u2019t use a single AsyncAPI document to define many of your message-driven APIs."),Object(s.b)("h2",{id:"organizing-client-server"},"Organizing Client-Server"),Object(s.b)("p",null,"Say, for instance, you have a WebSockets API and front-end application using it. The paradigm is very similar to the one we\u2019re used to with HTTP APIs, with the subtle difference that the communication is ",Object(s.b)("a",Object(o.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Duplex_%28telecommunications%29#Full_duplex"}),"full duplex"),", i.e., the client can send and receive messages over the same channel, at any time."),Object(s.b)("p",null,"This case is not very different from the microservices one. If you think about it, we can look at it as a small distributed architecture, where you only have two services: the client and the server. So the recommended best practice is to follow the same approach and have one document for each of the applications\u200a\u2014\u200aone for the server and another for the client or front-end."),Object(s.b)("h2",{id:"summary"},"Summary"),Object(s.b)("p",null,"I want to reinforce the point that an AsyncAPI file is meant to define ",Object(s.b)("strong",{parentName:"p"},"the behavior of a single application"),". Keep this always in mind, and everything will make sense to you."),Object(s.b)("p",null,Object(s.b)("undefined",{parentName:"p"},"Happy coding! ",Object(s.b)("span",{role:"img","aria-label":"victory hand"},"\u270c\ufe0f"))),Object(s.b)("hr",null),Object(s.b)("p",null,"AsyncAPI is an open source project running on donations so ",Object(s.b)("strong",{parentName:"p"},"please ",Object(s.b)("a",Object(o.a)({parentName:"strong"},{href:"https://opencollective.com/asyncapi"}),"consider donating")),Object(s.b)("undefined",{parentName:"p"}," ",Object(s.b)("span",{role:"img","aria-label":"raising hands"},"\ud83d\ude4c"))))}u.isMDXComponent=!0},"7ljp":function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var o=n("q1tI"),r=n.n(o);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),u=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"===typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return(r.a.createElement(l.Provider,{value:t},e.children))},b="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return(r.a.createElement(r.a.Fragment,{},t))}},m=r.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=u(n),b=o,m=p["".concat(i,".").concat(b)]||p[b]||h[b]||a;return n?r.a.createElement(m,s(s({ref:t},l),{},{components:n})):r.a.createElement(m,s({ref:t},l))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"===typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[b]="string"===typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},Ff2n:function(e,t,n){"use strict";function o(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,"a",(function(){return o}))},Qetd:function(e,t,n){"use strict";var o=Object.assign.bind(Object);e.exports=o,e.exports.default=e.exports},wpbD:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/organizing-asyncapi-documents",function(){return n("5MvJ")}])},wx14:function(e,t,n){"use strict";function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e}).apply(this,arguments)}n.d(t,"a",(function(){return o}))}},[["wpbD",0,1]]]);