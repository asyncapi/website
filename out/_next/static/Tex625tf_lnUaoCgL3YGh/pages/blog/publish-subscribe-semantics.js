(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{"7ljp":function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return d}));var a=n("q1tI"),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=r.a.createContext({}),l=function(e){var t=r.a.useContext(p),n=t;return e&&(n="function"===typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=l(e.components);return(r.a.createElement(p.Provider,{value:t},e.children))},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return(r.a.createElement(r.a.Fragment,{},t))}},m=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),b=l(n),u=a,m=b["".concat(o,".").concat(u)]||b[u]||h[u]||i;return n?r.a.createElement(m,s(s({ref:t},p),{},{components:n})):r.a.createElement(m,s({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"===typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"===typeof e?e:a,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},Ff2n:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,"a",(function(){return a}))},Qetd:function(e,t,n){"use strict";var a=Object.assign.bind(Object);e.exports=a,e.exports.default=e.exports},dvlx:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/publish-subscribe-semantics",function(){return n("twTf")}])},twTf:function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return l}));var a=n("wx14"),r=n("Ff2n"),i=n("q1tI"),o=n.n(i),s=n("7ljp"),c=(o.a.createElement,{}),p="wrapper";function l(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(s.b)(p,Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("blockquote",null,Object(s.b)("p",{parentName:"blockquote"},"This post originally appeared on ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://community.ibm.com/community/user/integration/blogs/nic-townsend1/2021/04/01/publish-vs-subscribe-in-asyncapi-and-why-it-may-no"}),"IBM Integration Community"))),Object(s.b)("p",null,"As adoption of AsyncAPI increases, a frequent topic of conversation in the community is how to describe ",Object(s.b)("em",{parentName:"p"},"publish")," and ",Object(s.b)("em",{parentName:"p"},"subscribe")," semantics - both now and in future versions of the specification."),Object(s.b)("p",null,"In this blog post I aim to introduce the discussion and set you on the right path to document your event driven APIs."),Object(s.b)("p",null,"Or in other words, what code would you expect to be generated for the publish operation in the following AsyncAPI document?"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"    asyncapi: 2.0.0 \n      info:                   \n        title: My Application\n        version: 1.0 \n    servers:\n      bootstrap:\n        url: mybroker.com:3514\n        protocol: kafka\n    channels:\n      myChannel:\n        publish:\n          message:\n            payload:\n              type: string\n")),Object(s.b)("p",null,"If you would be surprised to hear that this would result in a Kafka Consumer, then you should keep reading!"),Object(s.b)("p",null,Object(s.b)("img",Object(a.a)({parentName:"p"},{src:"/img/posts/publish-subscribe-semantics/meme.webp",alt:"meme with phrase 'you keep using that word, I do not think you know what it means'"}))),Object(s.b)("h1",{id:"in-the-beginning"},"In the beginning"),Object(s.b)("p",null,"AsyncAPI started as an adaptation of OpenAPI - which describes synchronous ",Object(s.b)("em",{parentName:"p"},"request/response")," based APIs. In an OpenAPI world, you describe the application from the perspective of the client. Or in other words, the OpenAPI document describes how a client should interact with your application. The client and server communicate directly with each other.  "),Object(s.b)("p",null,Object(s.b)("img",Object(a.a)({parentName:"p"},{src:"/img/posts/publish-subscribe-semantics/REST.webp",alt:"server communicating with client"}))),Object(s.b)("p",null,"You document that a GET endpoint exists to access data, a POST endpoint exists to create data, etc. In all cases, a client speaks to the application (server) that is serving these endpoints."),Object(s.b)("p",null,"If you were implementing an application to honour the contract described in an OpenAPI document, you know to build route handlers that provide the documented endpoints for clients to access."),Object(s.b)("blockquote",null,Object(s.b)("p",{parentName:"blockquote"},"Callbacks and webhooks are asynchronous operations, but in OpenAPI they are still described from the perspective of the client \u2013 the client has to initiate/register with the server before the server will push data to the client.")),Object(s.b)("h1",{id:"what-about-asyncapi"},"What about AsyncAPI?"),Object(s.b)("p",null,"In an event driven architecture there is no client/server paradigm. Applications do not directly communicate with one another - instead, each application sends and receives events via communication channels provided by s messaging infrastructure such as a broker. The broker ensures that events sent to a channel are delivered to interested applications. It can be considered ",Object(s.b)("em",{parentName:"p"},"fire and forget")," - an application sends an event, but does not have any interest in whether other applications receive or make use of the event."),Object(s.b)("p",null,"AsyncAPI approaches this by describing an application as having two potential roles:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"If it sends messages to a channel, it's a \u201cPublisher\"."),Object(s.b)("li",{parentName:"ul"},'If it is interested in receiving messages from a channel, it is a \u201cSubscriber".')),Object(s.b)("p",null,"An application can have either one or both roles."),Object(s.b)("p",null,"What does the following AsyncAPI document describe?"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"    asyncapi: 2.0.0\xa0\n      info:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        title: My Application\n        version: 1.0\xa0\n    servers:\n      bootstrap:\n        url: mybroker.com:3514\n        protocol: kafka\n    channels:\n      myChannel:\n        publish:\n          message:\n            payload:\n              type: string\n")),Object(s.b)("p",null,"Is ",Object(s.b)("em",{parentName:"p"},"My Application")," a Publisher or a Subscriber?"),Object(s.b)("p",null,"Answer... it's a Subscriber!"),Object(s.b)("p",null,"Like with OpenAPI, an AsyncAPI documents an application from the ",Object(s.b)("em",{parentName:"p"},"client")," perspective. For a client to interact with ",Object(s.b)("em",{parentName:"p"},"My Application"),", it must publish an event to the myChannel channel on the Kafka broker hosted at mybroker.com:3514  "),Object(s.b)("p",null,Object(s.b)("img",Object(a.a)({parentName:"p"},{src:"/img/posts/publish-subscribe-semantics/BROKER.webp",alt:"clients communicating via a broker"}))),Object(s.b)("blockquote",null,Object(s.b)("p",{parentName:"blockquote"},"The exception to the rule is websockets - there is a client/server paradigm rather than a messaging infrastructure - so other applications will connect directly to the server. However, the semantics remain the same - you describe the server as an application from the ",Object(s.b)("em",{parentName:"p"},"client")," perspective. ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://asyncapi.org/blog/websocket-part2"}),"See Lukasz's previous article for more details.")," ")),Object(s.b)("h1",{id:"wheres-the-confusion"},"Where's the confusion?"),Object(s.b)("p",null,"An AsyncAPI document can have multiple purposes. It can act as documentation for other developers to understand how to interact with the API. It can also act as documentation for developers to implement the API."),Object(s.b)("p",null,"In OpenAPI, there is no ambiguity - if you implement the API your server must listen for incoming requests on the documented endpoints, and any clients know to make requests to the documented endpoints. A GET endpoint means the same thing to both client and server."),Object(s.b)("p",null,"In AsyncAPI, the confusion has arisen because applications can both publish and subscribe - so ",Object(s.b)("strong",{parentName:"p"},"verbs become interchangeable depending on the perspective of the person reading the document.")),Object(s.b)("p",null,"When describing your architecture - a collection of applications communicating via channels - it can feel more familiar to describe what each application is doing (it publishes event ",Object(s.b)("em",{parentName:"p"},"x")," to channel ",Object(s.b)("em",{parentName:"p"},"a")," and subscribes to events from channel ",Object(s.b)("em",{parentName:"p"},"b"),")."),Object(s.b)("p",null,"Conversely, if you are intending on socialising your asynchronous API for use by other developers - it is a more familiar paradigm to describe how external developers can interact with the API. Ultimately, that was the decision for v2.0.0 of the AsyncAPI specification."),Object(s.b)("h1",{id:"what-does-this-mean-for-using-the-spec"},"What does this mean for using the spec?"),Object(s.b)("p",null,"The ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/asyncapi/generator"}),"AsyncAPI generator project")," is designed to facilitate generation of various assets from an AsyncAPI document - including sample or mock applications. The application generators are primarily written to interpret the API as detailed in this blog post - so a ",Object(s.b)("inlineCode",{parentName:"p"},"publish")," will generate a Kafka consumer. However, some of the templates have added support for interpreting the document so that a ",Object(s.b)("inlineCode",{parentName:"p"},"publish")," generates a Kafka producer.  "),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/asyncapi/java-spring-cloud-stream-template#parameters"}),"Java Spring Cloud Stream template")," uses the parameter ",Object(s.b)("inlineCode",{parentName:"li"},"view=provider")," - (",Object(s.b)("inlineCode",{parentName:"li"},"provider"),"\xa0interprets the AsyncAPI document as describing the behaviours the application ",Object(s.b)("em",{parentName:"li"},"provides"),")"),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/asyncapi/java-spring-template#supported-parameters"}),"Java Spring template")," use the parameter ",Object(s.b)("inlineCode",{parentName:"li"},"inverseOperations=true"))),Object(s.b)("h1",{id:"summary"},"Summary"),Object(s.b)("p",null,"AsyncAPI documents describe applications. When reading an AsyncAPI document:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"publish")," means ",Object(s.b)("em",{parentName:"li"},"publish an event to the channel and this application will receive it")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"subscribe")," means ",Object(s.b)("em",{parentName:"li"},"subscribe to this channel to receive events published by this application"))),Object(s.b)("p",null,"There is a ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/asyncapi/spec/issues/520"}),"GitHub issue")," raised for discussing these semantics moving forward into the next version of the AsyncAPI specification - please do get involved with the discussion!"))}l.isMDXComponent=!0},wx14:function(e,t,n){"use strict";function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}n.d(t,"a",(function(){return a}))}},[["dvlx",0,1]]]);